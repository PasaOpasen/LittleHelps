<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Классы</name>
    </assembly>
    <members>
        <member name="T:МатКлассы.BeeHiveAlgorithm">
            <summary>
            Реализация алгоритма роя частиц и подобных
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Parabol">
            <summary>
            Многомерная парабола
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Rastr">
            <summary>
            Функция Растригина
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Shvel">
            <summary>
            Функция Швеля
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.w">
            <summary>
            Параметры шага для роя
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.fp">
            <summary>
            Параметры шага для роя
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.fg">
            <summary>
            Параметры шага для роя
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{МатКлассы.Vectors,System.Double},System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Int32,МатКлассы.Vectors,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="n">Размерность области определения целевой функции</param>
            <param name="min">Минимальное возможное значение каждого аргумента</param>
            <param name="max">Максимальное возможное значение каждого аргумента</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода (подряд)</param>
            <param name="center">Центр распредления точек</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(МатКлассы.Vectors[],System.Func{МатКлассы.Vectors,System.Double},System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="n">Размерность области определения целевой функции</param>
            <param name="min">Минимальное возможное значение каждого аргумента</param>
            <param name="max">Максимальное возможное значение каждого аргумента</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода (подряд)</param>
            <param name="center">Центр распредления точек</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{МатКлассы.Vectors,System.Double},МатКлассы.Vectors,МатКлассы.Vectors,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="minimum">Вектор минимальных значений</param>
            <param name="maximum">Вектор максимальных значений</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Gets(МатКлассы.BeeHiveAlgorithm.Hive,System.Double,System.Int32,System.Int32)">
            <summary>
            Найти минимум функции уже по готовому рою
            </summary>
            <param name="hive"></param>
            <param name="eps"></param>
            <param name="maxcountstep"></param>
            <param name="maxiter"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Hive">
            <summary>
            Рой пчёл
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Hive.bees">
            <summary>
            Массив пчёл
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive.g">
            <summary>
            Наилучшее положение в рое
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive.val">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive.Radius">
            <summary>
            Радиус роя как наибольшее расстояние между наилучшим положением в рое и наилучшими положениями отдельных частиц
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive.UpdateG(МатКлассы.Vectors)">
            <summary>
            Попытаться обновить наилучшее положение
            </summary>
            <param name="gnew"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive.#ctor(МатКлассы.Vectors,МатКлассы.Vectors,System.Func{МатКлассы.Vectors,System.Double},System.Int32,МатКлассы.Vectors[])">
            <summary>
            Сгенерировать рой частиц
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
            <param name="count"></param>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive.MakeStep(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Сделать шаг по дискретному времени
            </summary>
            <param name="w"></param>
            <param name="fp"></param>
            <param name="fg"></param>
            <param name="parallel"></param>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Bee">
            <summary>
            Классы пчелы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee.x">
            <summary>
            Текущее положение частицы
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee.p">
            <summary>
            Наилучшее положение частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee.v">
            <summary>
            Текущая скорость частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee.random">
            <summary>
            Генератор случайных чисел
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee.bestval">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee.f">
            <summary>
            Целевая функция
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.#ctor(МатКлассы.Vectors,МатКлассы.Vectors,System.Func{МатКлассы.Vectors,System.Double})">
            <summary>
            Создать частицу в окне решений
            </summary>
            <param name="min">Минимальные возможные значения положения</param>
            <param name="max">Максимальные возможные значения положения</param>
            <param name="f">Целевая функция</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.#ctor(МатКлассы.Vectors,МатКлассы.Vectors,МатКлассы.Vectors,System.Func{МатКлассы.Vectors,System.Double})">
            <summary>
            Задать пчелу по известному начальному положению
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.WhenX(МатКлассы.Vectors,МатКлассы.Vectors,System.Func{МатКлассы.Vectors,System.Double})">
            <summary>
            Задать наилучшее положение и случайные скорости, когда x уже известно
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.RecalcVOld(System.Double,System.Double,System.Double,МатКлассы.Vectors)">
            <summary>
            Переопределить скорость
            </summary>
            <param name="w">Коэффициент инерции</param>
            <param name="fp">Весовой коэффициент для p</param>
            <param name="fg">Весовой коэффициент для g</param>
            <param name="g">Наилучшее положение по рою</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.RecalcV(System.Double,System.Double,System.Double,МатКлассы.Vectors)">
            <summary>
            Переопределить скорость
            </summary>
            <param name="w">Коэффициент инерции</param>
            <param name="fp">Весовой коэффициент для p</param>
            <param name="fg">Весовой коэффициент для g</param>
            <param name="g">Наилучшее положение по рою</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.Move">
            <summary>
            Сделать шаг по скорости
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee.ReCount">
            <summary>
            Переопределить наилучшее положение частицы, если можно
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{МатКлассы.Point,System.Double},МатКлассы.Point,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="n">Размерность области определения целевой функции</param>
            <param name="min">Минимальное возможное значение каждого аргумента</param>
            <param name="max">Максимальное возможное значение каждого аргумента</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода</param>
            <param name="center">Центр распредления точек</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{МатКлассы.Point,System.Double},МатКлассы.Point,МатКлассы.Point,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="minimum">Вектор минимальных значений</param>
            <param name="maximum">Вектор максимальных значений</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Gets2D(МатКлассы.BeeHiveAlgorithm.Hive2D,System.Double,System.Int32,System.Int32)">
            <summary>
            Найти минимум функции уже по готовому рою
            </summary>
            <param name="hive"></param>
            <param name="eps"></param>
            <param name="maxcountstep"></param>
            <param name="maxiter"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Hive2D">
            <summary>
            Рой пчёл
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Hive2D.bees">
            <summary>
            Массив пчёл
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive2D.g">
            <summary>
            Наилучшее положение в рое
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive2D.val">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive2D.Radius">
            <summary>
            Радиус роя как наибольшее расстояние между наилучшим положением в рое и наилучшими положениями отдельных частиц
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive2D.UpdateG(МатКлассы.Point)">
            <summary>
            Попытаться обновить наилучшее положение
            </summary>
            <param name="gnew"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive2D.#ctor(МатКлассы.Point,МатКлассы.Point,System.Func{МатКлассы.Point,System.Double},System.Int32,МатКлассы.Point[])">
            <summary>
            Сгенерировать рой частиц
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
            <param name="count"></param>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive2D.MakeStep(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Сделать шаг по дискретному времени
            </summary>
            <param name="w"></param>
            <param name="fp"></param>
            <param name="fg"></param>
            <param name="parallel"></param>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Bee2D">
            <summary>
            Классы пчелы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee2D.x">
            <summary>
            Текущее положение частицы
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee2D.p">
            <summary>
            Наилучшее положение частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee2D.v">
            <summary>
            Текущая скорость частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee2D.random">
            <summary>
            Генератор случайных чисел
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee2D.bestval">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee2D.f">
            <summary>
            Целевая функция
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee2D.#ctor(МатКлассы.Point,МатКлассы.Point,System.Func{МатКлассы.Point,System.Double})">
            <summary>
            Создать частицу в окне решений
            </summary>
            <param name="min">Минимальные возможные значения положения</param>
            <param name="max">Максимальные возможные значения положения</param>
            <param name="f">Целевая функция</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee2D.#ctor(МатКлассы.Point,МатКлассы.Point,МатКлассы.Point,System.Func{МатКлассы.Point,System.Double})">
            <summary>
            Задать пчелу по известному начальному положению
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee2D.RecalcV(System.Double,System.Double,System.Double,МатКлассы.Point)">
            <summary>
            Переопределить скорость
            </summary>
            <param name="w">Коэффициент инерции</param>
            <param name="fp">Весовой коэффициент для p</param>
            <param name="fg">Весовой коэффициент для g</param>
            <param name="g">Наилучшее положение по рою</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee2D.Move">
            <summary>
            Сделать шаг по скорости
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee2D.ReCount">
            <summary>
            Переопределить наилучшее положение частицы, если можно
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="n">Размерность области определения целевой функции</param>
            <param name="min">Минимальное возможное значение каждого аргумента</param>
            <param name="max">Максимальное возможное значение каждого аргумента</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода</param>
            <param name="center">Центр распредления точек</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Получить минимум функции, посчитанный роевым методом
            </summary>
            <param name="f">Целевая функция</param>
            <param name="minimum">Вектор минимальных значений</param>
            <param name="maximum">Вектор максимальных значений</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="countpoints">Количество пчёл в рое</param>
            <param name="maxcountstep">Максимальное число неудачных итераций метода</param>
            <param name="maxiter">Максимальное число итераций метода</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Gets1D(МатКлассы.BeeHiveAlgorithm.Hive1D,System.Double,System.Int32,System.Int32)">
            <summary>
            Найти минимум функции уже по готовому рою
            </summary>
            <param name="hive"></param>
            <param name="eps"></param>
            <param name="maxcountstep"></param>
            <param name="maxiter"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Hive1D">
            <summary>
            Рой пчёл
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Hive1D.bees">
            <summary>
            Массив пчёл
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive1D.g">
            <summary>
            Наилучшее положение в рое
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive1D.val">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Hive1D.Radius">
            <summary>
            Радиус роя как наибольшее расстояние между наилучшим положением в рое и наилучшими положениями отдельных частиц
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive1D.UpdateG(System.Double)">
            <summary>
            Попытаться обновить наилучшее положение
            </summary>
            <param name="gnew"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive1D.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Int32,System.Double[])">
            <summary>
            Сгенерировать рой частиц
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
            <param name="count"></param>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Hive1D.MakeStep(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Сделать шаг по дискретному времени
            </summary>
            <param name="w"></param>
            <param name="fp"></param>
            <param name="fg"></param>
            <param name="parallel"></param>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.Bee1D">
            <summary>
            Классы пчелы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee1D.x">
            <summary>
            Текущее положение частицы
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee1D.p">
            <summary>
            Наилучшее положение частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee1D.v">
            <summary>
            Текущая скорость частицы
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee1D.random">
            <summary>
            Генератор случайных чисел
            </summary>
        </member>
        <member name="P:МатКлассы.BeeHiveAlgorithm.Bee1D.bestval">
            <summary>
            Значение целевой функции в наилучшем положении
            </summary>
        </member>
        <member name="F:МатКлассы.BeeHiveAlgorithm.Bee1D.f">
            <summary>
            Целевая функция
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee1D.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double})">
            <summary>
            Создать частицу в окне решений
            </summary>
            <param name="min">Минимальные возможные значения положения</param>
            <param name="max">Максимальные возможные значения положения</param>
            <param name="f">Целевая функция</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee1D.#ctor(System.Double,System.Double,System.Double,System.Func{System.Double,System.Double})">
            <summary>
            Задать пчелу по известному начальному положению
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee1D.RecalcV(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Переопределить скорость
            </summary>
            <param name="w">Коэффициент инерции</param>
            <param name="fp">Весовой коэффициент для p</param>
            <param name="fg">Весовой коэффициент для g</param>
            <param name="g">Наилучшее положение по рою</param>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee1D.Move">
            <summary>
            Сделать шаг по скорости
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.Bee1D.ReCount">
            <summary>
            Переопределить наилучшее положение частицы, если можно
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.GetGlobalMin(System.Func{МатКлассы.Vectors,System.Double},МатКлассы.Vectors,МатКлассы.Vectors,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Оптимизация методом пчелиной колонии
            </summary>
            <param name="f">Оптимизируемая функция</param>
            <param name="min">Нижняя граница области решений</param>
            <param name="max">Верхняя граница области решений</param>
            <param name="n">Размерность области решений</param>
            <param name="s">Общее число пчёл</param>
            <param name="p">Число пчёл, выбранных для последующего исследования (p меньше s)</param>
            <param name="e">Число особо исследуемых пчёл (e меньше p)</param>
            <param name="sp">Число вспомогательных пчёл для пчёл из p</param>
            <param name="se">Число вспомогательных пчёл для пчёл из e</param>
            <param name="delta">Радиус окрестности</param>
            <param name="eps">Допустимая погрешность</param>
            <param name="maxcount">Максимальное число итераций</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.BeeHiveAlgorithm.SBee">
            <summary>
            Класс упрощённой пчелы
            </summary>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.SBee.GetBest(МатКлассы.BeeHiveAlgorithm.SBee[])">
            <summary>
            Наилучшая пчела в массиве (у которой наименьшее значение)
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.SBee.Create(System.Func{МатКлассы.Vectors,System.Double},МатКлассы.Vectors,МатКлассы.Vectors,System.Int32,System.Boolean)">
            <summary>
            Получить случайный массив упрощённых пчёл
            </summary>
            <param name="f"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="count">Число пчёл</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.BeeHiveAlgorithm.SBee.MakeStep(МатКлассы.BeeHiveAlgorithm.SBee[]@,System.Func{МатКлассы.Vectors,System.Double},МатКлассы.Vectors,МатКлассы.Vectors,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Сделать шаг по алгоритму пчелиной колонии
            </summary>
            <param name="mas"></param>
            <param name="f"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="n"></param>
            <param name="p"></param>
            <param name="e"></param>
            <param name="sp"></param>
            <param name="se"></param>
            <param name="delta"></param>
        </member>
        <member name="T:МатКлассы.Coding">
            <summary>
            Класс кодирования-декодирования
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.TempList">
            <summary>
            Набор промежуточной информации
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.HofTable">
            <summary>
            Таблица сопоставления символам двоичных чисел
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.abc">
            <summary>
            Набор возможных символов
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.randabc">
            <summary>
            Рандомизированный алфавит
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.TablePolib">
            <summary>
            Таблица для шифра Полибия
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.TablePlay">
            <summary>
            Таблица для шифра Плейфера
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.TableVert">
            <summary>
            Таблица для маршрутной перестановки
            </summary>
        </member>
        <member name="F:МатКлассы.Coding.FreqMas">
            <summary>
            Массив принятых частот символов
            </summary>
        </member>
        <member name="M:МатКлассы.Coding.Hacking(System.String)">
            <summary>
            Попытка взлома по частоте символов
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Zesar(System.String,System.Boolean,System.Int32)">
            <summary>
            Шифр цезаря
            </summary>
            <param name="s"></param>
            <param name="key"></param>
            <param name="encode"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Simple(System.String,System.Boolean,System.String)">
            <summary>
            Простая замена
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Polib(System.String,System.Boolean,System.String)">
            <summary>
            Шифр Полибия
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Playfer(System.String,System.Boolean,System.String)">
            <summary>
            Шифр Плейфера
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Vert(System.String,System.Boolean,System.String)">
            <summary>
            Маршрутная (вертикальная) перестановка
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.Coding.DoubleCharTable">
            <summary>
            Таблица сопоставления действительным числам из кодировки символа Unicode
            </summary>
        </member>
        <member name="M:МатКлассы.Coding.DoubleMasToUnicodeString(System.Double[])">
            <summary>
            Перевод массива чисел в строку символов Unicode (поддерживает около 130 000 разных символов) c параллельным заполнением таблицы соответствия
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.StringToDoubleMas(System.String)">
            <summary>
            Перевод строки в массив чисел с помощью таблицы соответствия
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Hoffman(System.String,System.Boolean)">
            <summary>
            Кодирование по алгоритму Хоффмана
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.HoffmanNumberEncode(System.Double[])">
            <summary>
            Кодировани набора чисел в набор двоичных чисел в два этапа (массив чисел -> строка символов -> строка двоичных чисел)
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.HoffmanNunderDecode(System.String)">
            <summary>
            Перевод набора двоичных чисел в массив строк в два этапа
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.VigenereEncode(System.String,System.String)">
            <summary>
            Кодирование шифром Виженера
            </summary>
            <param name="input"></param>
            <param name="keyword"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.VigenereDecode(System.String,System.String)">
            <summary>
            Декодирование шифром Виженера
            </summary>
            <param name="input"></param>
            <param name="keyword"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Generate_Pseudorandom_KeyWord(System.Int32,System.Int32)">
            <summary>
            Генерация случайного шифра по длине и спец. числу
            </summary>
            <param name="lenght"></param>
            <param name="startSeed"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Coding.Vernam(System.String,System.Boolean)">
            <summary>
            Шифр Вернама
            </summary>
            <param name="s"></param>
            <param name="encode"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Combinatorik">
            <summary>
            Методы комбинаторики
            </summary>
        </member>
        <member name="M:МатКлассы.Combinatorik.P(System.Int32)">
            <summary>
            Число перестановок (факториал)
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Combinatorik.P(System.Int32[])">
            <summary>
            Перестановки с повторениями
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Combinatorik.A(System.Int32,System.Int32)">
            <summary>
            Число размещений из n по m 
            </summary>
            <param name="m"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Combinatorik.AA(System.Int32,System.Int32)">
            <summary>
            Размещения с повторениями
            </summary>
            <param name="m"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Combinatorik.C(System.Int32,System.Int32)">
            <summary>
            Число сочетаний из n по m
            </summary>
            <param name="m"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Combinatorik.CС(System.Int32,System.Int32)">
            <summary>
            Сочетания с повторениями
            </summary>
            <param name="m"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.CSLAU">
            <summary>
            Класс комплексных СЛАУ
            Отличие от действительного случая в том, что реализация происходит через матрицы и векторы, а не через массивы
            Из-за комплексных чисел все методы надо переписывать
            </summary>
        </member>
        <member name="P:МатКлассы.CSLAU.Dim">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="M:МатКлассы.CSLAU.#ctor(МатКлассы.CSqMatrix,МатКлассы.CVectors)">
            <summary>
            Конструктор по матрице и свободному вектору
            </summary>
            <param name="M"></param>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.CSLAU.KramerSolve">
            <summary>
            Решение системы методом Крамера
            </summary>
        </member>
        <member name="M:МатКлассы.CSLAU.GaussSelection">
            <summary>
            Метод Гаусса, годный и при нулевых коэффициентах в системе
            </summary>
        </member>
        <member name="M:МатКлассы.CSLAU.Show">
            <summary>
            Вывести систему на консоль
            </summary>
        </member>
        <member name="T:МатКлассы.CSqMatrix">
            <summary>
            Квадратные комплексные матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.Re">
            <summary>
            Действительные и мнимые части комплексной матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.ComplexMas">
            <summary>
            Вернуть массив комплексных чисел исходной матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.RowCount">
            <summary>
            Число строк
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.ColCount">
            <summary>
            Число столбцов
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.CubeNorm">
            <summary>
            Кубическая норма матрицы как сумма кубических норма её действительной и мнимой части
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Индексатор
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.#ctor(МатКлассы.Number.Complex[0:,0:])">
            <summary>
            Конструктор по двумерному комплексному массиву
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Конструктор по двумерному действительному массиву
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.#ctor(МатКлассы.SqMatrix,МатКлассы.SqMatrix)">
            <summary>
            Конструктор по действительной и мнимой части матрицы
            </summary>
            <param name="R"></param>
            <param name="I"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.#ctor(МатКлассы.CSqMatrix)">
            <summary>
            Копирование комплексной матрицы
            </summary>
            <param name="M"></param>
        </member>
        <member name="P:МатКлассы.CSqMatrix.Det">
            <summary>
            Определитель матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.DetByMathNet">
            <summary>
            Определитель с помощью MathNet
            </summary>
        </member>
        <member name="M:МатКлассы.CSqMatrix.op_Explicit(МатКлассы.CSqMatrix)~МатКлассы.Number.Complex[0:,0:]">
            <summary>
            Преобразование матрицы в комплексный массив
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.PrintMatrix">
            <summary>
            Выдать матрицу в консоль
            </summary>
        </member>
        <member name="M:МатКлассы.CSqMatrix.ColumnSwap(System.Int32,МатКлассы.CVectors)">
            <summary>
            Замена колонны указанным вектором (для метода Крамера)
            </summary>
            <param name="ColumnNumber">Номер колонны</param>
            <param name="newColumn">Новая колонна</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.GetLine(System.Int32)">
            <summary>
            Вернуть строку матрицы
            </summary>
            <param name="k">Номер строки, начиная от 0</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.GetColumn(System.Int32)">
            <summary>
            Вернуть столбец матрицы
            </summary>
            <param name="k">Номер столбца, начиная от 0</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.ReversColumns(System.Int32,System.Int32)">
            <summary>
            Переставить местами столбцы с указанными индексами, нумерация начинается с 1
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.MultplyRows(МатКлассы.Number.Complex,System.Int32[])">
            <summary>
            Умножить в матрице какие-то строки на число
            </summary>
            <param name="c">Коэффициент</param>
            <param name="k">Массив индексов строк, индексы начинаются с 1</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.DivByLine(System.Int32,МатКлассы.Number.Complex)">
            <summary>
            Поделить строку в матрице на число
            </summary>
            <param name="i"></param>
            <param name="val"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.MinusVector(System.Int32,МатКлассы.CVectors)">
            <summary>
            Отнять от строки матрицы вектор
            </summary>
            <param name="i"></param>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.Invert(System.Boolean)">
            <summary>
            Обратная матрица по Гауссу
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.MaxLine(System.Int32,System.Int32)">
            <summary>
            Выдаёт индекс строки, содержащей максимальный элемент по столбцу column в диапазоне rowbeg...column.Len
            </summary>
            <param name="rowbeg"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.InvertAlg">
            <summary>
            Обратная матрица через алглиб
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.InvertByMathNet">
            <summary>
            Обратная матрица через метод из библиотеки MathNet. Когда мой метод работает хорошо, этот в половине случаев работает ещё лучше. Но когда у меня плохо, у этого лучше только на доли процентов
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.Invert2">
            <summary>
            Обращение матрицы 2х2
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.Invert4">
            <summary>
            Обращение матрицы 4х4
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.CSqMatrix.InvertSum">
            <summary>
            Обратная матрица, полученная через сумму степеней
            </summary>
        </member>
        <member name="M:МатКлассы.CSqMatrix.CharactPol(МатКлассы.CSqMatrix)">
            <summary>
            Характеристический многочлен заданной матрицы
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.ReverseCorrect(МатКлассы.CSqMatrix,МатКлассы.CSqMatrix,System.Double,System.Int32,System.Boolean)">
            <summary>
            Уточнение обратной матрицы
            </summary>
            <param name="A">Исходная матрица</param>
            <param name="Reverse">Обратная марица</param>
            <param name="eps">Точность</param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.CSqMatrix.Track">
            <summary>
            Track матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.CSqMatrix.dup">
            <summary>
            Дубликат
            </summary>
        </member>
        <member name="M:МатКлассы.CSqMatrix.GetMinMat(System.Int32,System.Int32)">
            <summary>
            Возвращает матрицу, полученную из исходной исключением строки row и столбца col (начинаются с 1)
            </summary>
            <param name="col"></param>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CSqMatrix.FastLessen(МатКлассы.CSqMatrix)">
            <summary>
            Ускоренное отнятие другой матрицы от исходной
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.CSqMatrix.FastAdd(МатКлассы.CSqMatrix)">
            <summary>
            Ускоренное добавление другой матрицы от исходной
            </summary>
            <param name="M"></param>
        </member>
        <member name="T:МатКлассы.Curve">
            <summary>
            Класс плоских кривых 
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.U">
            <summary>
            Параметризации координат в зависимости от параметра и радиуса
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.V">
            <summary>
            Параметризации координат в зависимости от параметра и радиуса
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.uuu">
            <summary>
            Поля, рассчитанные под параметризацию границы области (на случай, если границу области нужно задать немного иначе, потому что функция имеет особенности)
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.vvv">
            <summary>
            Поля, рассчитанные под параметризацию границы области (на случай, если границу области нужно задать немного иначе, потому что функция имеет особенности)
            </summary>
        </member>
        <member name="P:МатКлассы.Curve.u">
            <summary>
            Свойства, выдающие параметризацию границы области
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.S">
            <summary>
            Площадь сегмента
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.a">
            <summary>
            Начальное значение параметра
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.b">
            <summary>
            Конечное значение параметра
            </summary>
        </member>
        <member name="F:МатКлассы.Curve._h">
            <summary>
            Значение шага интегрирования для этой кривой
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.M">
            <summary>
            Число шагов при интегрировании
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.radius">
            <summary>
            Базовый радиус кривой
            </summary>
        </member>
        <member name="P:МатКлассы.Curve.BaseRadius">
            <summary>
            Базовый радиус кривой
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.End">
            <summary>
            Функция, выдающая нужную длину отрезка параметризации в зависимости от радиуса, поскольку иногда отрезок изменения параметра t зависит от r
            </summary>
        </member>
        <member name="F:МатКлассы.Curve.ITER_INTEG">
            <summary>
            Количество шагов при интегрировании по умолчанию
            </summary>
        </member>
        <member name="M:МатКлассы.Curve.Transfer(System.Double)">
            <summary>
            Возврат точки на кривой по значению параметра
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Curve.TRANSFER">
            <summary>
            Свойство, выдающее и принимающее делегат, отображающий параметры в точку на кривой
            </summary>
        </member>
        <member name="M:МатКлассы.Curve.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>
            Кривая по своей параметризации
            </summary>
            <param name="a0">Начальное значение параметра</param>
            <param name="b0">Конечное значение параметра</param>
            <param name="uu">Отображение в первую координату</param>
            <param name="vv">Отображение во вторую координату</param>
        </member>
        <member name="M:МатКлассы.Curve.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Кривая по своей параметризации и базовому радиусу
            </summary>
            <param name="a0"></param>
            <param name="b0"></param>
            <param name="uu"></param>
            <param name="vv"></param>
            <param name="BASEradius"></param>
        </member>
        <member name="M:МатКлассы.Curve.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,МатКлассы.DRealFunc,МатКлассы.DRealFunc,МатКлассы.TripleFunc,System.Func{System.Double,System.Double})">
            <summary>
            Кривая по всем своим параметрам
            </summary>
            <param name="a0"></param>
            <param name="b0"></param>
            <param name="uu"></param>
            <param name="vv"></param>
            <param name="BASEradius"></param>
            <param name="uuu"></param>
            <param name="vvv"></param>
        </member>
        <member name="M:МатКлассы.Curve.#ctor(System.Double,System.Double,МатКлассы.DRealFunc,МатКлассы.DRealFunc,System.Double)">
            <summary>
            Кривая по своей параметризации и базовому радиусу
            </summary>
            <param name="a0"></param>
            <param name="b0"></param>
            <param name="uu"></param>
            <param name="vv"></param>
            <param name="BaseRadius"></param>
        </member>
        <member name="M:МатКлассы.Curve.#ctor">
            <summary>
            Кривая, вырожденная в начало координат (все поля - нули)
            </summary>
        </member>
        <member name="M:МатКлассы.Curve.#ctor(System.Double,System.Double,МатКлассы.DPointFunc,System.Double,МатКлассы.TripleFunc,System.Func{System.Double,System.Double})">
            <summary>
            Конструктор кривой, которая задаётся не через пары параметрических функций 
            </summary>
            <param name="a0">Начало отрезка параметризации</param>
            <param name="b0">Конец отрезка параметризации</param>
            <param name="Tr">Функция, выдающая точку на кривой в зависимости от параметра и радиуса кривой</param>
            <param name="BaseRad">Базовый радиус</param>
            <param name="T">Площадь сегмента</param>
            <param name="end">Возврат конца отрезка параметризации в зависимости от радиуса</param>
        </member>
        <member name="M:МатКлассы.Curve.Firstkind(МатКлассы.Functional)">
            <summary>
            Вычисление криволинейного интеграла первого рода по этой кривой от функции f методом Гаусса 
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Cut">
            <summary>
            Класс отрезков на плоскости
            </summary>
        </member>
        <member name="P:МатКлассы.Cut.FirstPoint">
            <summary>
            Первая точка на прямой (начало отрезка)
            </summary>
        </member>
        <member name="P:МатКлассы.Cut.SecondPoint">
            <summary>
            Вторая точка на прямой (конец отрезка)
            </summary>
        </member>
        <member name="P:МатКлассы.Cut.Line">
            <summary>
            Прямая, на которой лежит отрезок
            </summary>
        </member>
        <member name="P:МатКлассы.Cut.Length">
            <summary>
            Длина отрезка
            </summary>
        </member>
        <member name="M:МатКлассы.Cut.#ctor(МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Задать отрезок по его концам
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:МатКлассы.Cut.Transfer(System.Double)">
            <summary>
            Выводит точку на отрезке, соответствующую естественному параметру
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.CVectors">
            <summary>
            Комплексные векторы
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.Item(System.Int32)">
            <summary>
            Индексатор
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.CVectors.ComplexMas">
            <summary>
            Комплексный массив, отождествлённый с вектором
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.Re">
            <summary>
            Действительная часть вектора
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.Im">
            <summary>
            Комплексная часть вектора
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.AbsVector">
            <summary>
            Вектор модулей
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.Degree">
            <summary>
            Размерность вектора
            </summary>
        </member>
        <member name="P:МатКлассы.CVectors.Abs">
            <summary>
            Модуль вектора как сумма евклидовых норм действительной и мнимой части
            </summary>
        </member>
        <member name="M:МатКлассы.CVectors.#ctor(МатКлассы.Number.Complex[])">
            <summary>
            Коплексный вектор по комплексному массиву 
            </summary>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.CVectors.#ctor(System.Double[])">
            <summary>
            Комплексный вектор по действительному массиву
            </summary>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.CVectors.#ctor(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Комплексный вектор по действительной и мнимой части
            </summary>
            <param name="R"></param>
            <param name="I"></param>
        </member>
        <member name="M:МатКлассы.CVectors.#ctor(System.Int32)">
            <summary>
            Пустой комплексный вектор указанной размерности
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.CVectors.#ctor(МатКлассы.CVectors)">
            <summary>
            Копирование коплексного вектора
            </summary>
            <param name="v"></param>
        </member>
        <member name="P:МатКлассы.CVectors.Conjugate">
            <summary>
            Комплексно сопряженный вектор
            </summary>
        </member>
        <member name="M:МатКлассы.CVectors.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CVectors.op_Explicit(МатКлассы.CVectors)~МатКлассы.Vectors">
            <summary>
            Преобразование комплексного вектора в действительный (по действительной части)
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.CVectors.op_Implicit(МатКлассы.Vectors)~МатКлассы.CVectors">
            <summary>
            Преобразование действительной вектора в комплексный
            </summary>
            <param name="v"></param>
        </member>
        <member name="P:МатКлассы.CVectors.EmptyVector">
            <summary>
            Пустой комплексный вектор
            </summary>
        </member>
        <member name="M:МатКлассы.CVectors.FastAdd(МатКлассы.CVectors)">
            <summary>
            Быстрое добавление к вектору другого вектора
            </summary>
            <param name="v"></param>
        </member>
        <member name="P:МатКлассы.CVectors.Normalize">
            <summary>
            Нормализованный вектор
            </summary>
        </member>
        <member name="M:МатКлассы.CVectors.op_Multiply(МатКлассы.CVectors,МатКлассы.CVectors)">
            <summary>
            Скалярное произведение векторов
            </summary>
            <param name="q"></param>
            <param name="w"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Expendator">
            <summary>
            Класс расширений для всяких методов
            </summary>
        </member>
        <member name="M:МатКлассы.Expendator.ToFunctional(МатКлассы.RealFuncOfCompArg)">
            <summary>
            Перевести действительную функцию комплексного переменного в функционал
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToRealFuncOfCompArg(МатКлассы.Functional)">
            <summary>
            Перевести функционал в действительную функцию комплексного переменного
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToCompFunc(МатКлассы.Functional)">
            <summary>
            Перевести функционал в функцию комплесного переменного
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToCompFunc(МатКлассы.RealFuncOfCompArg)">
            <summary>
            Преобразовать действительную функцию комплексного переменного в комплексную функцию
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Min(System.Double[])">
            <summary>
            Минимальное из кучи
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Max(System.Double[])">
            <summary>
            Максимальное из кучи
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Max(System.Int32[])">
            <summary>
            Максимальное из кучи
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Show``1(``0)">
            <summary>
            Вывести строковое предаставление типа на консоль
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:МатКлассы.Expendator.Show``1(``0[])">
            <summary>
            Строковое представление массива
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.Expendator.Sum(МатКлассы.SequenceFunc,System.Double,System.Int32)">
            <summary>
            Сумма первых N членов функционального ряда в точке x
            </summary>
            <param name="f"></param>
            <param name="x"></param>
            <param name="N"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Average(МатКлассы.Number.Complex,МатКлассы.Number.Complex)">
            <summary>
            Более точное среднее арифметическое для двух чисел
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToDouble(System.String)">
            <summary>
            Переводит строку в действительное число через конвертер
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToDoubleMas(МатКлассы.Number.Complex[])">
            <summary>
            Выдаёт массив действительных частей элементов комплексного массива
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToDoubleMas``1(``0[])">
            <summary>
            Переводит произвольный массив в массив действительных чисел через конвертер
            </summary>
            <typeparam name="T"></typeparam>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToIntMas``1(``0[])">
            <summary>
            Переводит произвольный массив в массив целых чисел через конвертер
            </summary>
            <typeparam name="T"></typeparam>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToIntMas(System.String)">
            <summary>
            Перевести строку с числами в набор чисел
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToStringMas``1(``0[])">
            <summary>
            Переводит произвольный массив в массив строк через конвертер
            </summary>
            <typeparam name="T"></typeparam>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Union``1(``0[],``0[])">
            <summary>
            Конкатенация двух массивов
            </summary>
            <typeparam name="T"></typeparam>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Without``1(``0[],``0)">
            <summary>
            Возвращает исходный массив без указанного элемента
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="elem"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Compar.Compare(System.Double,System.Double)">
            <summary>
            Компаратор по модулю
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.DimOfFractionalPath(System.Double)">
            <summary>
            Размерность дробной части (количество знаков после запятой)
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Average(System.Int32,System.Int32)">
            <summary>
            Среднее двух целых чисел (по правилам целочисленного деления)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToPeriod(System.Double,System.Double)">
            <summary>
            Сокращение числа на период
            </summary>
            <param name="d"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToSystemNumComplex(МатКлассы.CSqMatrix)">
            <summary>
            Перевод матрицы в массив System.Numerics.Complex
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToCSqMatrix(System.Numerics.Complex[0:,0:])">
            <summary>
            Перевод в матрицу массива System.Numerics.Complex
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToString(System.Double,System.Int32)">
            <summary>
            Перевод числа в строку с обрезанием дробной части (оставить только n знаков после запятой)
            </summary>
            <param name="d"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToSpline(МатКлассы.FuncMethods.NetFunc,System.Double,System.Double,System.Boolean)">
            <summary>
            Кубический сплайн по сеточной функции с коэффициентами условий на границе
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="is0outcut">Должна ли функция равняться 0 вне отрезка задания</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Sum(МатКлассы.Number.Complex[])">
            <summary>
            Сумма комплексного массива
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Adding(МатКлассы.Number.Complex[],МатКлассы.Number.Complex[])">
            <summary>
            Сумма комплексных массивов
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Add(МатКлассы.Number.Complex[],МатКлассы.Number.Complex[])">
            <summary>
            Сумма комплексных массивов
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Re(МатКлассы.Number.Complex[])">
            <summary>
            Действительная часть комплексного массива
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ReOf(МатКлассы.Number.Complex[])">
            <summary>
            Действительная часть комплексного массива
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.EmptyLine(System.Int32)">
            <summary>
            Вывести пустую строку
            </summary>
        </member>
        <member name="M:МатКлассы.Expendator.MaxApproxAbs(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double)">
            <summary>
            Примерный максимум модуля функции на отрезке
            </summary>
            <param name="f"></param>
            <param name="beg"></param>
            <param name="end"></param>
            <param name="step"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Distinct(System.Double[],System.Double[],System.Double)">
            <summary>
            Объединение двух массивов с удалением одного из двух близких (ближе eps) друг к другу элементов
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="eps"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Div(МатКлассы.Number.Complex[],МатКлассы.Number.Complex)">
            <summary>
            Деление комплексного массива на комплексное число
            </summary>
            <param name="mas"></param>
            <param name="coef"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Multiply(МатКлассы.Number.Complex[],МатКлассы.Number.Complex)">
            <summary>
            Умножение комплексного массива на комплексное число
            </summary>
            <param name="mas"></param>
            <param name="coef"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Mult(МатКлассы.Number.Complex[],МатКлассы.Number.Complex)">
            <summary>
            Умножение комплексного массива на комплексное число
            </summary>
            <param name="mas"></param>
            <param name="coef"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Mult(System.ValueTuple{МатКлассы.Number.Complex,МатКлассы.Number.Complex},МатКлассы.Number.Complex)">
            <summary>
            Умножение пары комплексных чисел на комплексное числл
            </summary>
            <param name="mas"></param>
            <param name="coef"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.WriteInFile(System.String,МатКлассы.Vectors[])">
            <summary>
            Записать массив векторов в файл
            </summary>
            <param name="name"></param>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.Expendator.StartProcess(System.String,System.Action)">
            <summary>
            Запустить процесс и выполнить какие-то действия по его окончанию
            </summary>
            <param name="fileName"></param>
            <param name="act"></param>
        </member>
        <member name="M:МатКлассы.Expendator.Dup``1(``0[])">
            <summary>
            Дубликат массива
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.dup``1(``0[])">
            <summary>
            Дубликат массива
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>
            Срез массива
            </summary>
            <param name="mas"></param>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Slice(System.Double[],System.Int32,System.Int32)">
            <summary>
            Срез массива
            </summary>
            <param name="mas"></param>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToDoubleMas(System.String)">
            <summary>
            Преобразовать строку в массив действительных чисел
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToRString(System.Double)">
            <summary>
            Преобразовать число в строку, из которой его можно воспроизвести
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Seq(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Создать и заполнить массив алгебраической прогрессией
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Map``2(``1[],System.Func{``1,``0})">
            <summary>
            Применяет функцию к массиву и возвращает массив результатов
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="mas"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.BinarySearch(System.Double[],System.Double)">
            <summary>
            Возвращает пару индексов массива, между элементами которого находится искомый элемент либо пару одинаковых индексов, когда элемент совпадает с каким-то элементом массива
            </summary>
            <param name="w"></param>
            <param name="el"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetPeriod``1(``0[])">
            <summary>
            Найти период в массиве
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetProcent(System.Double,System.Double)">
            <summary>
            Получить отношение двух чисел в процентах
            </summary>
            <param name="exist"></param>
            <param name="all"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetProcent(System.Double,System.Double,System.Int32)">
            <summary>
            Вернуть округлённый процент
            </summary>
            <param name="exist"></param>
            <param name="all"></param>
            <param name="mantis"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.WriteStringInFile(System.String,System.String)">
            <summary>
            Записать одно слово в файл
            </summary>
            <param name="filename"></param>
            <param name="word"></param>
        </member>
        <member name="M:МатКлассы.Expendator.WriteInFile(System.String,System.String[],System.Int32)">
            <summary>
            Записать массив слов в файл
            </summary>
            <param name="filename"></param>
            <param name="word"></param>
            <param name="withoutfromend">Определяет, сколько строк с конца добавлять не нужно</param>
        </member>
        <member name="M:МатКлассы.Expendator.GetStringArrayFromFile(System.String,System.Boolean)">
            <summary>
            Прочесть все строки файла
            </summary>
            <param name="filename"></param>
            <param name="withoutEmpty">Определяет, нужно ли считывать пустые строки</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetWordFromFile(System.String)">
            <summary>
            Получить первую строку из файла
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.IfDirectoryExists(System.String,System.String@)">
            <summary>
            Определяет директорию, считанную из файла и возвращает ответ о её существовании
            </summary>
            <param name="filename"></param>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.CopyFiles(System.String,System.String,System.String[])">
            <summary>
            Скопировать набор файлов из одной директории в другую, сохраняя имена
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="filenames"></param>
        </member>
        <member name="M:МатКлассы.Expendator.GetResource(System.String,System.String)">
            <summary>
            Возвращает полный адрес ресурса по его краткому имени и проекту
            </summary>
            <param name="name">Имя файла с расширением</param>
            <param name="projectname">Имя проекта</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetResource(System.String)">
            <summary>
            Возвращает полный адрес ресурса по его краткому имени и проекту
            </summary>
            <param name="name">Имя файла с расширением</param>
        </member>
        <member name="M:МатКлассы.Expendator.StringArrayToString(System.String[])">
            <summary>
            Переводит массив строк в одну строку
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.ToStringFromExp(System.Int32[])">
            <summary>
            Записать массив чисел в строку
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Max(System.Int32[],System.Int32[])">
            <summary>
            Покомпонентный массив максимумов
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.Repeat(System.Int32,System.Int32)">
            <summary>
            Повторить число count раз
            </summary>
            <param name="number"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.DirectoryCopyAsync(System.String,System.String)">
            <summary>
            Осуществить копирование папки
            </summary>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="M:МатКлассы.Expendator.IndexesWhichGetSum(System.Int32[],System.Int32)">
            <summary>
            Возвращает индексы элементов массива, сумма которых равна указанному значению
            </summary>
            <param name="arr"></param>
            <param name="sum"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetRandomNumberFromArrayWithProbabilities(System.Int32[],System.Double[])">
            <summary>
            Возвращает случайное число из массива vals с вероятностью из массива probs
            </summary>
            <param name="vals"></param>
            <param name="probs"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetRandomElementFromArrayWithProbabilities``1(``0[],System.Double[])">
            <summary>
            Возвращает случайный элемент из массива vals с вероятностью из массива probs
            </summary>
            <param name="vals"></param>
            <param name="probs"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Expendator.GetRandomElementFromArrayWithProbabilities``1(``0[],System.Int32[])">
            <summary>
            Возвращает случайный элемент из массива vals с вероятностью из массива probs
            </summary>
            <param name="vals"></param>
            <param name="probs"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods">
            <summary>
            Методы, связанные с функциями
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Monoms">
            <summary>
            Система мономов
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Monom">
            <summary>
            Система мономов как полиномы
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Lezhandrs(System.Double,System.Double)">
            <summary>
            Система многочленов Лежандра, ортогональных на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Lezhandr(System.Double,System.Double)">
            <summary>
            Система многочленов Лежандра как многочленов, ортогональных на отрезке
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Chebs(System.Double,System.Double)">
            <summary>
            Система многочленов Чебышева, ортогональных на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Cheb(System.Double,System.Double)">
            <summary>
            Система многочленов Чебышева как многочленов, ортогональных на отрезке
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Lagerrs(System.Double,System.Double)">
            <summary>
            Система многочленов Лагерра, ортогональных на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Hermits(System.Double,System.Double)">
            <summary>
            Система многочленов Эрмита, ортогональных на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.TrigSystem(System.Double,System.Double)">
            <summary>
            Тригонометрическая система, ортогональная на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.HaarSystem(System.Double,System.Double)">
            <summary>
            Система функций Хаара, ортогональных на отрезке
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.GaussBell(System.Double,System.Double)">
            <summary>
            Колокол Гаусса
            </summary>
            <param name="mean"></param>
            <param name="sd"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.GaussBell2(System.Double,System.Double)">
            <summary>
            Нормированный колокол Гаусса
            </summary>
            <param name="mean"></param>
            <param name="sd"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Approx(System.Func{System.Double,System.Double},МатКлассы.SequenceFunc,МатКлассы.SequenceFuncKind,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Аппроксимация функций системой функций на отрезке
            </summary>
            <param name="f">Функция, которую надо аппроксимировать</param>
            <param name="p">Функция, зависящая от действительного аргумента и номера</param>
            <param name="kind">Класс функций в системе (ортогональные/ортонормальные/другие)</param>
            <param name="n">Число функций из системы</param>
            <param name="a">Начало отрезка</param>
            <param name="b">Конец отрезка</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Approx(System.Func{System.Double,System.Double},МатКлассы.SequencePol,МатКлассы.SequenceFuncKind,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Аппроксимация функций системой полиномов на отрезке
            </summary>
            <param name="f">Функция, которую надо аппроксимировать</param>
            <param name="p">Полином из некоторой системы</param>
            <param name="kind">Класс функций в системе (ортогональные/ортонормальные/другие)</param>
            <param name="n">Число функций из системы</param>
            <param name="a">Начало отрезка</param>
            <param name="b">Конец отрезка</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Approx(МатКлассы.FuncMethods.NetFunc,МатКлассы.SequenceFunc,МатКлассы.SequenceFuncKind,System.Int32)">
            <summary>
            Аппроксимация сеточной функции системой функций
            </summary>
            <param name="f">Сеточная функция, которую требуется аппроксимировать</param>
            <param name="p">Аппроксимирующие функции из некоторой системы</param>
            <param name="kind">Характер аппроксимирующих функций (ортогональные/ортонормальные/неортогональные)</param>
            <param name="n">Размерность системы (по умолчанию совпадает с размерностью сеточной функции)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ShowApprox(System.Func{System.Double,System.Double},System.Double[],МатКлассы.SequenceFunc,МатКлассы.SequenceFuncKind,System.Int32)">
            <summary>
            Продемонстрировать аппроксимацию сеточной функции (созданной по действительной) системой функций
            </summary>
            <param name="f">Действительная функция (по которой строится сеточная)</param>
            <param name="c">Узлы (абциссы) для сеточной функции</param>
            <param name="p">Аппроксимирующие функции из некоторой системы</param>
            <param name="kind">Характер аппроксимирующих функций (ортогональные/ортонормальные/неортогональные)</param>
            <param name="n">Размерность системы (по умолчанию совпадает с размерностью сеточной функции)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ShowApprox(МатКлассы.FuncMethods.NetFunc,МатКлассы.SequenceFunc,МатКлассы.SequenceFuncKind,System.Int32)">
            <summary>
            Продемонстрировать аппроксимацию только сеточной функции системой функций
            </summary>
            <param name="g">Сеточная функция</param>
            <param name="p">Аппроксимирующие функции из некоторой системы</param>
            <param name="kind">Характер аппроксимирующих функций (ортогональные/ортонормальные/неортогональные)</param>
            <param name="n">Размерность системы (по умолчанию совпадает с размерностью сеточной функции)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ShowApprox(System.Func{System.Double,System.Double},МатКлассы.SequenceFunc,МатКлассы.SequenceFuncKind,System.Int32,System.Double,System.Double)">
            <summary>
            Продемонстрировать аппроксимацию действительной функции системой функций
            </summary>
            <param name="f"></param>
            <param name="p"></param>
            <param name="kind"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.ShowApprox(System.Func{System.Double,System.Double},МатКлассы.SequencePol,МатКлассы.SequenceFuncKind,System.Int32,System.Double,System.Double)">
            <summary>
            Продемонстрировать аппроксимацию действительной функции системой функций
            </summary>
            <param name="f"></param>
            <param name="p"></param>
            <param name="kind"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:МатКлассы.FuncMethods.RealFuncMethods">
            <summary>
            Методы для действительных функций
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.RealFuncMethods.ScalarPower(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Стандартное скалярное произведение функций
            </summary>
            <param name="f"></param>
            <param name="g"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.RealFuncMethods.NormScalar(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Норма L(2)[a,b] функции через скалярное произведение
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.RealFuncMethods.NormDistance(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Расстояние между функциями по норме L(2)[a,b]
            </summary>
            <param name="f"></param>
            <param name="g"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.RealFuncMethods.NormC(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Норма функции в пространстве С[a,b]
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.RealFuncMethods.NormDistanceС(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Расстояние между функциями по норме С[a,b]
            </summary>
            <param name="f"></param>
            <param name="g"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.MatrixFunc`2">
            <summary>
            Матричные и векторные функции
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.MatrixFunc`2.Value">
            <summary>
            Главная функция экземпляра класса
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.MatrixFunc`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Нулевая матрица указанной размерности
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.MatrixFunc`2.#ctor(МатКлассы.FuncMethods.MatrixFunc{`0,`1}.Delegate)">
            <summary>
            Создание матричной функции по делегату
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.MatrixFunc`2.#ctor(МатКлассы.FuncMethods.MatrixFunc{`0,`1})">
            <summary>
            Конструктор копирования
            </summary>
            <param name="w"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.MatrixFunc`2.#ctor(System.Func{`0,`1,System.Double}[])">
            <summary>
            Вектор-функция по массиву функций
            </summary>
            <param name="F"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.MatrixFunc`2.#ctor(System.Func{`0,`1,System.Double}[0:,0:])">
            <summary>
            Матричная функция по массиву функций
            </summary>
            <param name="F"></param>
        </member>
        <member name="P:МатКлассы.FuncMethods.MatrixFunc`2.Item(`0,`1)">
            <summary>
            Значение экземпляра класса на аргументах
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization">
            <summary>
            Методы оптимизации
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.EPS">
            <summary>
            Точность методов
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.STEP">
            <summary>
            Шаг
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.s">
            <summary>
            Максимальный шаг поиска корня
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization.ModifyFunction">
            <summary>
            Контроль над тем, модифицируется функция в методе или нет
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.ModifyFunction.Yes">
            <summary>
            Да, модифицировать функцию
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.ModifyFunction.No">
            <summary>
            Нет, не модифицировать функцию
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Bisec(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Метод бисекции(дихотомии)
            </summary>
            <param name="f">Комплексная функция</param>
            <param name="a">Начало отрезка поиска корня</param>
            <param name="b">Конец отрезка поиска корня</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.W(МатКлассы.FuncMethods.Optimization.PointC[],System.Int32,System.Int32)">
            <summary>
            Разделённая разность по массиву точек (с рекурсией)
            </summary>
            <param name="p">Массив точек</param>
            <param name="i">Номер начального элемента в разности</param>
            <param name="j">Номер конечного элемента в разности</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.FullMuller(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Поиск всех корней комплексной функции с действительной частью на указанном действительном отрезке
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Muller(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.Number.Complex)">
            <summary>
            Метод Мюллера (парабол) поиска нуля функции
            </summary>
            <param name="f">Функция комплексного переменного</param>
            <param name="x1">Первая точка</param>
            <param name="x2">Вторая точка</param>
            <param name="x3">Третья точка</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.MinUnder(МатКлассы.Number.Complex[],МатКлассы.Number.Complex)">
            <summary>
            Наименее отклоняющаяся от комплексного числа точка из массива 
            </summary>
            <param name="x"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Chord(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Метод хорд поиска корня
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization.Variety">
            <summary>
            Вариация метода
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.Variety.Simple">
            <summary>
            Простейшая вариация метода
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.Variety.Usual">
            <summary>
            Традиционная вариация метода
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Neu(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.FuncMethods.Optimization.Variety,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Метод Ньютона поиска корня
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.ChordNeu(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Комбинированный метод поиска корня
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.MinSearch(МатКлассы.RealFuncOfCompArg,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.FuncMethods.Optimization.MinimumVar,System.Double)">
            <summary>
            Поиск экстремумов функции указанным методом
            </summary>
            <param name="ff">Функция комплексного переменного</param>
            <param name="a">Начало отрезка поиска</param>
            <param name="b">Конец отрезка поиска</param>
            <param name="M">Метод локального поиска</param>
            <param name="s">Максимальный шаг поиска</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization.MinimumVar">
            <summary>
            Методы поиска минимума
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.MinimumVar.GoldSection">
            <summary>
            Метод золотого сечения
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.MinimumSearch(МатКлассы.RealFuncOfCompArg,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.FuncMethods.Optimization.MinimumVar)">
            <summary>
            Поиск минимума функции указанным методом
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.GoldSect(МатКлассы.RealFuncOfCompArg,МатКлассы.Number.Complex,МатКлассы.Number.Complex)">
            <summary>
            Метод золотого сечения поиска минимума функции на указанном отрезке
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Exter(МатКлассы.RealFuncOfCompArg,МатКлассы.Number.Complex[])">
            <summary>
            Вернуть из нескольких чисел наиболее близкую к экстремуму точку
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Presentaion(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,МатКлассы.FuncMethods.Optimization.ModifyFunction)">
            <summary>
            Презентация работы группы методов поиска корня
            </summary>
            <param name="f">Функция комплексного переменного</param>
            <param name="a">Начало отрезка поиска</param>
            <param name="b">Конец отрезка поиска</param>
            <param name="s">Максимальный шаг поиска</param>
            <param name="Mod">Искать/не искать кратные корни</param>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization.CriticalPoint">
            <summary>
            Ключевая точка
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.CriticalPoint.Root">
            <summary>
            Корень
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.CriticalPoint.Minimum">
            <summary>
            Минимум
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.Optimization.RootSearchMethod">
            <summary>
            Методы поиска корня
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.RootSearchMethod.Bisec">
            <summary>
            Метод бисекции
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.RootSearchMethod.Muller">
            <summary>
            Метод парабол
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.RootSearchMethod.Chord">
            <summary>
            Метод хорд
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.RootSearchMethod.Neu">
            <summary>
            Метод Ньютона
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.Optimization.RootSearchMethod.ChordNeu">
            <summary>
            Комбинированный метод хорд-Ньютона
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.SearchRoots(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.FuncMethods.Optimization.RootSearchMethod,System.Double,System.Double)">
            <summary>
            Поиск корня комплексной функции в прямоугольнике
            </summary>
            <param name="ff">Комплексная функция</param>
            <param name="a">Правый верхний угол прямоугольника</param>
            <param name="b">Левый верхний угол прямоугольника</param>
            <param name="c">Левый нижний угол прямоугольника</param>
            <param name="d">Правый нижний угол прямоугольника</param>
            <param name="M">Метод поиска корня на отрезке</param>
            <param name="s">Шаг в методе поиска корня на отрезке</param>
            <param name="sh">Шаг параллельных прямых по прямоугольнику</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.Optimization.Halfc(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Массив действительных корней комплексной функции на отрезке
            </summary>
            <param name="f">Функция</param>
            <param name="tmin">Начало отрезка</param>
            <param name="tmax">Конец отрезка</param>
            <param name="step">Шаг</param>
            <param name="eps">Точность</param>
            <param name="Nmax">Число итераций</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.IntegralTransformations">
            <summary>
            Класс интегральных преобразований
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg">
            <summary>
            Определённые интегралы
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.STEP">
            <summary>
            Шаг при интегрировании
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.EPS">
            <summary>
            Оценка точности при интегрировании
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.n">
            <summary>
            Количество узлов
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.iter_count">
            <summary>
            Количество итераций при поиске корней многочлена
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.h_Count">
            <summary>
            Количество шагов при интегрировании
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.stx">
            <summary>
            Шаги интегрирования в кратном интеграле по умолчанию
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.sty">
            <summary>
            Шаги интегрирования в кратном интеграле по умолчанию
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.countY">
            <summary>
            Число колец по умолчанию
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.Method">
            <summary>
            Методы подсчёта интеграда
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.MiddleRect">
            <summary>
            Метод средних прямоугольников
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.Trapez">
            <summary>
            Метод трапеций
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.Simpson">
            <summary>
            Метод Симпсона
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.Gauss">
            <summary>
            Метод Гаусса
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.Meler">
            <summary>
            Метод Мелера (Эрмита)
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.GaussKronrod15">
            <summary>
            Метода Гаусса-Кронрода(по 15 точкам)
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.GaussKronrod61">
            <summary>
            Метод Гаусса-Кронрода по 61 точке
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.GaussKronrod61fromFortran">
            <summary>
            Метод Гаусса-Кронрода по 61 точкам на основе процедуры с фортрана
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.GaussKronrod61Empire">
            <summary>
            Метод Гаусса-Кронрода по 61 точке с эмпирическим делением отрезка
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Method.GaussKronrod61Sq">
            <summary>
            Метод Гаусса-Кронрода, рассчитанный на использование в сумме интегралов по малым отрезкам
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.Criterion">
            <summary>
            Критерии подсчёта интеграла
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Criterion.StepCount">
            <summary>
            Число шагов (узлов)
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Criterion.Accuracy">
            <summary>
            Точность
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.Criterion.SegmentCount">
            <summary>
            Разбиение на несколько отрезков
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.MiddleRect(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Нахождение определённого интеграла методом средних прямоугольников
            </summary>
            <param name="F">Действительная функция действительного аргумента</param>
            <param name="a">Первая точка промежутка интегрирования</param>
            <param name="b">Последняя точка промежутка интегрирования</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Trapez(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Нахождение определённого интеграла методом трапеций
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Simpson(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Нахождение определённого интеграла методом Симпсона
            </summary>
            <param name="F"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Gauss(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Нахождение определённого интеграла через квадратурные формулы Гаусса
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка итегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Meler(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Нахождение определённого интеграла через квадратурные формулы Мелера
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка итегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.GaussKronrod">
            <summary>
            Класс методов, связанных с вычислением интеграла квадратурами Гаусса-Кронрода
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.GaussKronrod.Myfunc">
            <summary>
            Процедурная реализация вектор-функции комплексного аргумента
            </summary>
            <param name="x">Аргумент</param>
            <param name="y">Вектор значений</param>
            <param name="N">Размерность вектора значений</param>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.GaussKronrod.ComplexVectorFunc">
            <summary>
            Комплексная вектор-функция
            </summary>
            <param name="x"></param>
            <param name="N"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount">
            <summary>
            Количество узлов при интегрировании
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.ChooseGK(МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount)">
            <summary>
            Выбрать метод в зависимости от узлов
            </summary>
            <param name="c"></param>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.GaussKronrod.Nodes">
            <summary>
            Размерность
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.GaussKronrod.Nodes61">
            <summary>
            Размерность
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.GK_adaptive_int(МатКлассы.FuncMethods.DefInteg.GaussKronrod.Myfunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,System.Double,МатКлассы.Number.Complex[]@,System.Int32)">
            <summary>
            Интеграл по коченому отрезку
            </summary>
            <param name="int_func">Интегрируемая функция</param>
            <param name="a">Начало отрезна интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="int_h">Начальный шаг</param>
            <param name="eps">Используемая погрешность</param>
            <param name="ret_arr">Вектор значений интеграла (результат)</param>
            <param name="N">Размерность вектора значений</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.Integral(МатКлассы.FuncMethods.DefInteg.GaussKronrod.Myfunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Double,System.Double,System.Int32)">
            <summary>
            Интеграл по коченому отрезку
            </summary>
            <param name="int_func">Интегрируемая функция</param>
            <param name="a">Начало отрезна интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="int_h">Начальный шаг</param>
            <param name="eps">Используемая погрешность</param>
            <param name="N">Размерность вектора значений</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.IntegralInf(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Int32,System.Int32,МатКлассы.ComplexFunc,System.Int32,System.Double,System.Double)">
            <summary>
            Интеграл по прямой
            </summary>
            <param name="int_func">Интегрируемая функция</param>
            <param name="a">Начало отрезна интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="int_h">Начальный шаг</param>
            <param name="eps">Используемая погрешность</param>
            <param name="N">Размерность вектора значений</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.IntegralHalfInf(МатКлассы.ComplexFunc,System.Double,System.Double,System.Int32,System.Int32,МатКлассы.ComplexFunc,System.Int32,System.Double,System.Double)">
            <summary>
            Интеграл по отрезку от a до +inf
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="n"></param>
            <param name="maxmult"></param>
            <param name="vareps"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.Integral(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Определённый интеграл
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.IntegralInf(МатКлассы.ComplexFunc,System.Double,System.Double,МатКлассы.ComplexFunc,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Несобственный интеграл по вещественной оси
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.GaussKronrod.LastListOfDINN5GK">
            <summary>
            Информация о последнем найденном с помощью DINN5_GK интеграле 
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.DINN5_GK(МатКлассы.FuncMethods.DefInteg.GaussKronrod.Myfunc,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,МатКлассы.Number.Complex[]@)">
             <summary>
             Базовый DINN с фортрана
             </summary>
             <param name="CF"></param>
             <param name="t1"></param>
             <param name="t2"></param>
             <param name="t3"></param>
             <param name="t4"></param>
             <param name="tm"></param>
             <param name="tp"></param>
             <param name="eps"></param>
             <param name="pr"></param>
             <param name="gr"></param>
             <param name="N"></param>
             <param name="Rd"></param>
             <remarks>
             ! Программа вычисления N интегралов по полубесконечному контуру 
            !           в случае обратной волны 
            !
            !  subroutine СF(u, s, n) - подынтегральные функции; u - аргумент(complex16),
            !                   s(n) - массив значений функций в точке u(complex16),
            !                   n - число интегралов(integer)
            ! [t1, t2],[t3, t4] - участки отклонения контура вниз(real8)
            !         [t2, t3] - участок отклонения контура вверх(real8)
            ! tm,tp > 0 - величины отклонения контура вниз и вверх(real8)
            ! (если нет обратной волны, то следует положить t2 = t3 = t1, tp = 0 
            !  обход полюсов при этом будет только снизу на участке[t1, t4]
            !  с отклонением на tm)
            ! eps -  отн.погрешность,  pr - начальный шаг,
            ! N- число интегралов(integer)
            ! Rd(N) - выход: массив значений интегралов
             </remarks>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.DINN_GK(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount)">
             <summary>
             Подсчёт несобственного комплексного интеграла от 0 до inf с учётом полюсов
             </summary>
             <param name="f">Функция комплексного переменного</param>
             <param name="t1"></param>
             <param name="t2"></param>
             <param name="t3"></param>
             <param name="t4"></param>
             <param name="tm">Величина отклонения контура вниз</param>
             <param name="tp">Величина отклонения контура вверх</param>
             <param name="eps">Погрешность</param>
             <param name="pr">Начальный шаг</param>
             <param name="gr">Верхний предел</param>
             <remarks>
             ВЗЯТО С ДОКУМЕНТАЦИИ ОТ ФОРТРАНА
             ! [t1,t2],[t3,t4] - участки отклонения контура вниз (real8)
            !         [t2, t3] - участок отклонения контура вверх(real8)
            ! tm,tp > 0 - величины отклонения контура вниз и вверх(real8)
            ! (если нет обратной волны, то следует положить t2 = t3 = t1, tp = 0 
            !  обход полюсов при этом будет только снизу на участке[t1, t4]
            !  с отклонением на tm)
             </remarks>
             <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.DINN_GK(System.Func{МатКлассы.Number.Complex,МатКлассы.Number.Complex},System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount)">
             <summary>
             Подсчёт несобственного комплексного интеграла от 0 до inf с учётом полюсов
             </summary>
             <param name="f">Функция комплексного переменного</param>
             <param name="t1"></param>
             <param name="t2"></param>
             <param name="t3"></param>
             <param name="t4"></param>
             <param name="tm">Величина отклонения контура вниз</param>
             <param name="tp">Величина отклонения контура вверх</param>
             <param name="eps">Погрешность</param>
             <param name="pr">Начальный шаг</param>
             <param name="gr">Верхний предел</param>
             <param name="nodesCount">Число узлов в квадратурах</param>
             <remarks>
             ВЗЯТО С ДОКУМЕНТАЦИИ ОТ ФОРТРАНА
             ! [t1,t2],[t3,t4] - участки отклонения контура вниз (real8)
            !         [t2, t3] - участок отклонения контура вверх(real8)
            ! tm,tp > 0 - величины отклонения контура вниз и вверх(real8)
            ! (если нет обратной волны, то следует положить t2 = t3 = t1, tp = 0 
            !  обход полюсов при этом будет только снизу на участке[t1, t4]
            !  с отклонением на tm)
             </remarks>
             <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.DINN_GKwith0(МатКлассы.ComplexFunc,System.Double,МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount)">
            <summary>
            Несобственный интеграл с нулевыми параметрами (если не надо делать обход контура)
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.DINN_GKwith0Full(МатКлассы.ComplexFunc,System.Double,МатКлассы.FuncMethods.DefInteg.GaussKronrod.NodesCount)">
            <summary>
            Несобственный интеграл по всей оси от конкретно этой функции
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.MySimpleGaussKronrod(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Взятый с alglib метод Гаусса-Кронрода с выбором числа точек
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.MySimpleGaussKronrod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Взятый с alglib метод Гаусса-Кронрода с выбором числа точек
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.MySimpleGaussKronrod(System.Func{МатКлассы.Number.Complex,МатКлассы.CVectors},МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Метод Гаусса-Кронрода с выбором числа точек
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="n">Число точек в методе Гаусса-Кронрода</param>
            <param name="ChooseStepByCompareRes">Требуется ли пересчитывать с меньшими отрезками, если разница между методами Гаусса и Гаусса-Кронрода существенная</param>
            <param name="MaxDivCount">Сколько ещё раз можно поделить отрезок (максимальное число делений)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.MySuperGaussKronrod(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,МатКлассы.ComplexFunc,System.Int32,System.Int32,System.Double)">
            <summary>
            Метод Гаусса-Кронрода, который вместо отрезка делает обход контура, если на отрезке есть полюса
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="delta">Знаменатель интегрируемой функции</param>
            <param name="t">Предполагаемый радиус отрезка, вне которого полюсов нет</param>
            <param name="n">Число узлов интегрировани</param>
            <param name="h">Отклонение контура</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.ParallelGaussKronrod(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Int32,System.Int32)">
            <summary>
            Метод Гаусса-Кронрода, использующий параллельные вычисления за счёт разбиения отрезка интегрирования на несколько частей
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="n">Число точек в методе</param>
            <param name="count">На сколько отрезков разбиватся исходный отрезок</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.GaussKronrodSum(МатКлассы.ComplexFunc,МатКлассы.Number.Complex,МатКлассы.Number.Complex,System.Int32,System.Int32)">
            <summary>
            Взятый с alglib метод Гаусса-Кронрода с выбором числа точек
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.GaussKronrod.GaussKronrodSum(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Взятый с alglib метод Гаусса-Кронрода с выбором числа точек
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DefIntegral(System.Func{System.Double,System.Double},System.Double,System.Double,МатКлассы.FuncMethods.DefInteg.Method,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Подсчёт определённого интеграла выбранными методом и относительно выбранного критерия
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <param name="M">Метод подсчёта интеграла</param>
            <param name="C">Критерий подсчёта интеграла (указанное число шагов/точность/разбиение интеграла на сумму интегралов по нескольким частям отрезка интегрирования)</param>
            <param name="count">Число шагов при интегрировании</param>
            <param name="eps">Точность интеграла</param>
            <param name="seqcount">На сколько частей разбивается отрезок</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegral(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,МатКлассы.FuncMethods.DefInteg.Method,System.Double,System.Double,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Подсчёт кратного интеграла
            </summary>
            <param name="f">Функционал под интегралом</param>
            <param name="c">Кривая, являющаяся границей области интегрирования</param>
            <param name="S">Функция трёх переменных, задающая зависимость площади куска от параметров tx, ty и радиуса</param>
            <param name="M">Метод обычного интегрирования</param>
            <param name="C">Критерий интегрирования</param>
            <param name="count">Число шагов (тоже не требуется)</param>
            <param name="eps">Точность (требуется при определённом критерии интегрирования)</param>
            <param name="parallel">Требуется ли считать интегралы по кольцам параллельно</param>
            <param name="tx">Шаг "по кольцу"</param>
            <param name="ty">Шаг "по радиусу фигуры"</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegral(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,МатКлассы.FuncMethods.DefInteg.Method,System.Double,System.Int32,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Подсчёт кратного интеграла
            </summary>
            <param name="f">Функционал под интегралом</param>
            <param name="c">Граница области интегрирования</param>
            <param name="S">Функция, определяющая площадь сегмента</param>
            <param name="M">Метод интегрирования</param>
            <param name="tx">Шаг по кольцу</param>
            <param name="cy">Число колец</param>
            <param name="C">Критерий интегрирования</param>
            <param name="count"></param>
            <param name="eps"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegralInf(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,МатКлассы.FuncMethods.DefInteg.Method,System.Double,System.Int32,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Boolean,System.Boolean,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Подсчёт двойного интеграла на области, описываемой кривой при бесконечном радиусе
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="c">Кривая</param>
            <param name="S">Функция площади</param>
            <param name="M">Метод обычного интегрирования</param>
            <param name="tx">Шаг внутри кольца</param>
            <param name="cy">Число колец</param>
            <param name="C">Критерий интегрирования</param>
            <param name="count">Число шагов</param>
            <param name="eps">Погрешность</param>
            <param name="parallel">Нужно ли распараллеливание</param>
            <param name="makesort">Нужна ли сортировка данных</param>
            <param name="Rstep">Шаг по радиусу</param>
            <returns></returns>
            <remarks>Тестирование на вейвлетах показало, что увеличение радиуса колец увеличивает точность вычислений на доли процентов, зато время работы увеличивается на 20-30%, то есть вариант неоптимален</remarks>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegralIn_IandIV(МатКлассы.Functional,МатКлассы.FuncMethods.DefInteg.Method,System.Double,System.Int32,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Boolean,System.Boolean,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Подсчёт двойного интеграла в правой полуплоскости
            </summary>
            <param name="f"></param>
            <param name="M"></param>
            <param name="tx"></param>
            <param name="cy"></param>
            <param name="C"></param>
            <param name="count"></param>
            <param name="eps"></param>
            <param name="parallel"></param>
            <param name="makesort"></param>
            <param name="Rstep"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegralIn_FULL(МатКлассы.Functional,МатКлассы.FuncMethods.DefInteg.Method,System.Double,System.Int32,МатКлассы.FuncMethods.DefInteg.Criterion,System.Int32,System.Double,System.Boolean,System.Boolean,System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Подсчёт двойного интеграла для всей плоскости
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="M">Метод интегрирования</param>
            <param name="tx">Шаг по кольцу</param>
            <param name="cy">Число колец</param>
            <param name="C">Критерий (не следует менять)</param>
            <param name="count">Число отрезков разбиения (не надо трогать)</param>
            <param name="eps">Точность</param>
            <param name="parallel">Вычислять ли параллельно</param>
            <param name="makesort">Делать ли сортировку перед суммированием</param>
            <param name="Rstep">Шаг по радиусу колец</param>
            <param name="Rmax">Максимальный радиус</param>
            <param name="min_iter">Минимальное число итераций, которые требуется выполнить</param>
            <param name="changestepcount">Сколько раз изменять шаг (изменять шаг непроизводительно)</param>
            <param name="a">Первая полуось эллипса</param>
            <param name="b">Вторая полуось эллипса</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DoubleIntegralSuper(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,МатКлассы.FuncMethods.DefInteg.Method,System.Int32,System.Double,System.Int32)">
            <summary>
            Кратный интеграл по более точным квадратурам
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="c">Граница области интегрирования</param>
            <param name="S">Функция площади сегмента</param>
            <param name="M">Метод обычного интегрирования</param>
            <param name="cy">Число колец</param>
            <param name="rmin">Минимальный радиус</param>
            <param name="n">Число узлов в методе Гаусса-Кронрода для поиска криволинейного интеграла</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.MonteKarloEnum">
            <summary>
            Вариация метода Монте-Карло
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.MonteKarloEnum.Usual">
            <summary>
            Обычный
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.MonteKarloEnum.Geo">
            <summary>
            Геометрический
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.MonteKarlo(МатКлассы.MultiFunc,МатКлассы.FuncMethods.DefInteg.MonteKarloEnum,МатКлассы.Point[])">
            <summary>
            Подсчёт определённого интеграла методом Монте-Карло
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.ImproperFirstKind(System.Func{System.Double,System.Double})">
            <summary>
            Несобственный интеграл от минус бесконечности до бесконечности
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.ImproperFirstKindInf(System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Несобственный интеграл на отрезке от a до бесконечности
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Demonstration(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            Демонстрация посчёта интегралов разными методами
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Demonstration(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,System.Double[]@,System.TimeSpan[]@,System.Double,System.Int32,System.Boolean,System.Double,System.String)">
            <summary>
            Демонстрация подсчёта кратных интегралов
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="c">Граница области интегрирования</param>
            <param name="S">Функция площади</param>
            <param name="pog">Массив погрешностей от разных методов</param>
            <param name="time">Массив временных затрат от разных методов</param>
            <param name="tx">Шаг интегрирования</param>
            <param name="cy">Шаг по кольцу</param>
            <param name="existsolve">Выводить на консоль интегралы (либо погрешности)</param>
            <param name="integ">Истинное значение интеграла</param>
            <param name="s">Строка, в которой записана интегрируемая функция</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DemostrationToExcel(МатКлассы.Functional,МатКлассы.Curve,МатКлассы.TripleFunc,System.Int32[],System.Double,System.Double)">
            <summary>
            Оформление результатов кратного интегрирования разными методами в Excel
            </summary>
            <param name="f">Интегрируемая функция</param>
            <param name="c">Граница области</param>
            <param name="S">Функция площади</param>
            <param name="cy">Массив значений количества колец</param>
            <param name="tx">Шаг по кольцу</param>
            <param name="integ">Истинное значение интеграла</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.DemonstrationToFile(System.String,System.String,МатКлассы.Functional[],МатКлассы.Curve,МатКлассы.TripleFunc,System.Int32[],System.Double[],МатКлассы.FuncMethods.DefInteg.Method)">
            <summary>
            Записать в файл результаты вычисления интегралов от разных функций на одной и той же кривой
            </summary>
            <param name="eps">Файл, куда будут записываться данные число колец-точность</param>
            <param name="epstime">Файл, куда будут записываться данные число колец-точность*время вычислений</param>
            <param name="f">Массив интегрируемых функций</param>
            <param name="c">Граница области интегрирования</param>
            <param name="S">Функция площади</param>
            <param name="cy">Массив числа колец</param>
            <param name="integ">Массив интегралов</param>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.Residue">
            <summary>
            Класс методов с вычетами
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Residue.Derivative(МатКлассы.ComplexFunc,МатКлассы.Number.Complex)">
            <summary>
            Производная функции со вторым порядком точности
            </summary>
            <param name="f"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Residue.Res(МатКлассы.ComplexFunc,МатКлассы.ComplexFunc,МатКлассы.Number.Complex)">
            <summary>
            Вычет в точке (простом полюсе) у функции, представимой в виде частного, где полюс есть нуль знаменателя
            </summary>
            <param name="g">Числитель функции</param>
            <param name="d">Знаменатель функции</param>
            <param name="z">Полюс (простой)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.Residue.ResSum(МатКлассы.ComplexFunc,МатКлассы.ComplexFunc,МатКлассы.ComplexFunc,МатКлассы.Number.Complex[])">
            <summary>
            Сумма вычетов функции по набору полюсов
            </summary>
            <param name="g">Числитель функции</param>
            <param name="d">Знаменатель функции</param>
            <param name="qe">Дополнительный множитель, не содержащий особенностей в заданных полюсах</param>
            <param name="mas">Массив полюсов</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg">
            <summary>
            Кратный интеграл
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.ExternalLimitUp">
            <summary>
            Верхний внешний предел
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.ExternalLimitDown">
            <summary>
            Нижний внешний предел
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.InternalLimitUp">
            <summary>
            Верхний внутренний предел
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.InternalLimitDown">
            <summary>
            Нижний внутренний предел
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.#ctor(System.Double,System.Double,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>
            Конструктор по пределам интегрирования
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="af"></param>
            <param name="bf"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.DInteg(МатКлассы.Functional,МатКлассы.FuncMethods.DefInteg.Method,System.Int32)">
            <summary>
            Вычислить кратный интеграл
            </summary>
            <param name="f"></param>
            <param name="method"></param>
            <param name="stepcount"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.DefInteg.AreaForDoubleInteg.DInteg(МатКлассы.Functional,System.Int32,System.Boolean)">
            <summary>
            Вычислить кратный интеграл
            </summary>
            <param name="f"></param>
            <param name="method"></param>
            <param name="stepcount"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.NetFunc">
            <summary>
            Сеточная функция
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.NetFunc.Knots">
            <summary>
            Список узлов
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.NetFunc.Lag">
            <summary>
            Интерполяционный многочлен Лагранжа для этой сеточной функции
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.NetFunc.R">
            <summary>
            Интерполяционная рациональная функция для этой сеточной функции
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.NetFunc.CubeSpline">
            <summary>
            Интерполяционный кубический сплайн для этой сеточной функции
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.LastVal">
            <summary>
            Значение сеточной функции в конце области определения
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.LastArg">
            <summary>
            Последний аргумент сеточной функции
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Values">
            <summary>
            Массив значений сеточной функции
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor">
            <summary>
            Конструктор по умолчанию
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(МатКлассы.FuncMethods.NetFunc)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(System.Collections.Generic.List{МатКлассы.Point})">
            <summary>
            Генерация сеточной функции по списку точек
            </summary>
            <param name="L"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(МатКлассы.Point[])">
            <summary>
            Генерация сеточной функции по массиву точек
            </summary>
            <param name="P"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(System.IO.StreamReader)">
            <summary>
            Генерация сеточной функции по массиву точек, расположенному в файле
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double)">
            <summary>
            Генерация сеточной функции по точкам от действительной функции
            </summary>
            <param name="f">Действительная функция</param>
            <param name="n">Число точек</param>
            <param name="a">Начало отрезка интерполяции</param>
            <param name="b">Конец отрезка интерполяции</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(System.Func{System.Double,System.Double},System.Double[])">
            <summary>
            Генерация сеточной функции по действительной фунции и набору абцисс
            </summary>
            <param name="f"></param>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(System.Double[],System.Double[])">
            <summary>
            Задание сеточной функции по массиву узлов и массиву значений в узлах
            </summary>
            <param name="arg"></param>
            <param name="val"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.#ctor(МатКлассы.FuncMethods.NetFunc[])">
            <summary>
            Усреднённая сеточная функция с условием, что все сеточные функции определены на одной и той же сетке
            </summary>
            <param name="mas"></param>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Item(System.Int32)">
            <summary>
            Значение сеточной функции в такой-то точке её сетки
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Arg(System.Int32)">
            <summary>
            Аргумент сеточной функции в таком-то узле её сетки
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Arguments">
            <summary>
            Массив аргументов сеточной функции
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.CountKnots">
            <summary>
            Количество узлов
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.MinArg">
            <summary>
            Минимальный аргумент
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.MaxArg">
            <summary>
            Максимальный аргумент
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Lagrange">
            <summary>
            Интерполяционный полином Лагранжа этой сеточной функции
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Spline">
            <summary>
            Интерполяционный кубический сплайн этой сеточной функции
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.RatFunc(System.Int32,System.Int32)">
            <summary>
            Интерполяционная рациональная функция этой сеточной функции
            </summary>
        </member>
        <member name="P:МатКлассы.FuncMethods.NetFunc.Points">
            <summary>
            Массив узлов сеточной функции
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Add(МатКлассы.Point)">
            <summary>
            Добавить узел в функцию
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Delete(System.Int32)">
            <summary>
            Удалить элемент из списка
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Delete(System.Double)">
            <summary>
            Удалить элемент с указанной абциссой
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Clear">
            <summary>
            Очистить список узлов
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Value(System.Double)">
            <summary>
            Значение сеточной функции в точке, наиболее близкой к точке x
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Show">
            <summary>
            Вывести массив узлов на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.ScalarP(МатКлассы.FuncMethods.NetFunc,МатКлассы.FuncMethods.NetFunc)">
            <summary>
            Скалярное произведение сеточных функций
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.ScalarP(МатКлассы.FuncMethods.NetFunc,System.Func{System.Double,System.Double})">
            <summary>
            Скалярное произведение сеточной и действительной функции
            </summary>
            <param name="a"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.ScalarP(System.Func{System.Double,System.Double},МатКлассы.FuncMethods.NetFunc)">
            <summary>
            Скалярное произведение сеточной и действительной функции
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.ScalarP(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double[])">
            <summary>
            Скалярное произведение двух действителььных функций на сетке
            </summary>
            <param name="f"></param>
            <param name="g"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Norm(МатКлассы.FuncMethods.NetFunc)">
            <summary>
            Норма сеточной функции
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Distance(МатКлассы.FuncMethods.NetFunc,МатКлассы.FuncMethods.NetFunc)">
            <summary>
            Расстояние между сеточными функциями
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.NetFunc.Distance(МатКлассы.FuncMethods.NetFunc,System.Func{System.Double,System.Double})">
            <summary>
            Расстояние между сеточной функцией и действительной функцией
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.FuncMethods.ODU">
            <summary>
            Класс решения ОДУ
            </summary>
        </member>
        <member name="T:МатКлассы.FuncMethods.ODU.Method">
            <summary>
            Метод решения ОДУ
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.E1">
            <summary>
            Метод Эйлера
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.E2">
            <summary>
            Метод Эйлера с пересчётом
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.H">
            <summary>
            Метод Хойна
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.RK3">
            <summary>
            Метод Рунге-Кутты 3 порядка
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.RK4">
            <summary>
            Метод Рунге-Кутты 4 порядка
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.P38">
            <summary>
            Правило трёх восьмых
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.F">
            <summary>
            Метод Фельдберга
            </summary>
        </member>
        <member name="F:МатКлассы.FuncMethods.ODU.Method.C">
            <summary>
            Метод Ческино
            </summary>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.ODUsearch(МатКлассы.DRealFunc,System.Double,System.Double,System.Double,МатКлассы.FuncMethods.ODU.Method,System.Double,System.Double,System.Boolean)">
            <summary>
            Решение приведённого ОДУ первого порядка
            </summary>
            <param name="f">Свободная функция переменных u и x, где u - искомая функция</param>
            <param name="begin">Начальный аргумент по задаче Коши</param>
            <param name="end">Конечный аргумент</param>
            <param name="step">Шаг интегрирования</param>
            <param name="M">Метод поиска решения</param>
            <param name="begval">Значение функции при начальном аргументе</param>
            <param name="eps">Допустимый уровень расчётных погрешностей</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.ODUsearch(МатКлассы.DRealFunc,System.Double,System.Double,System.Int32,МатКлассы.FuncMethods.ODU.Method,System.Double,System.Double)">
            <summary>
            Решение приведённого ОДУ первого порядка
            </summary>
            <param name="f">Свободная функция переменных u и x, где u - искомая функция</param>
            <param name="begin">Начальный аргумент по задаче Коши</param>
            <param name="end">Конечный аргумент</param>
            <param name="stepcount">Количество шагов интегрирования</param>
            <param name="M">Метод поиска решения</param>
            <param name="begval">Значение функции при начальном аргументе</param>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.ODUsearch(МатКлассы.VRealFunc,МатКлассы.Vectors,System.Double,System.Double,System.Double,МатКлассы.FuncMethods.ODU.Method,System.Double,System.Boolean)">
            <summary>
            Решение системы ОДУ первого порядка
            </summary>
            <param name="f">Свободная функция переменных u и x, где u - искомая функция</param>
            <param name="begin">Начальный аргумент по задаче Коши</param>
            <param name="end">Конечный аргумент</param>
            <param name="step">Шаг интегрирования</param>
            <param name="M">Метод поиска решения</param>
            <param name="begval">Значение функции при начальном аргументе</param>
            <param name="eps">Допустимый уровень расчётных погрешностей</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.ShootQu(МатКлассы.VRealFunc,МатКлассы.TwoVectorToVector,МатКлассы.Vectors,System.Collections.Generic.List{МатКлассы.VectorFunc}@,System.Collections.Generic.List{МатКлассы.Vectors}@,System.Collections.Generic.List{System.Collections.Generic.List{System.Tuple{System.Double,МатКлассы.Vectors}}}@,System.Double,System.Double,System.Int32,МатКлассы.FuncMethods.ODU.Method,System.Double,System.Double,System.Boolean)">
            <summary>
            Решение задачи о стрельбе
            </summary>
            <param name="f">Свободная функция в системе ОДУ</param>
            <param name="F">Функция из граничных условий</param>
            <param name="alp">Вектор альфа начального приближения при поиске корня</param>
            <param name="list">Промежуточный список вектор-функций</param>
            <param name="vlist">Промежуточный список векторов</param>
            <param name="netlist">Промежуточный список вектор-функций (так как делегаты передаются плохо)</param>
            <param name="begin">Начало отрезка задания аргумента</param>
            <param name="end">Конец отрезка задания аргумента</param>
            <param name="stepcount">Число шагов при решении ОДУ</param>
            <param name="M">Метод решения ОДУ</param>
            <param name="eps">Погрешность</param>
            <param name="l">Коэффициент для метода итераций</param>
            <param name="controlstep">Нужно ли следить за шагом при решении ОДУ</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.SchLiuQu(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double@,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Решение задачи Штурма-Лиувилля
            </summary>
            <param name="g">Функция внутри второй производной</param>
            <param name="h">Функция при первой производной</param>
            <param name="s">Функция при искомой функции</param>
            <param name="f">Свободная функция</param>
            <param name="a">Начало отрезка</param>
            <param name="b">Конец отрезка</param>
            <param name="N">Число шагов</param>
            <param name="A"></param>
            <param name="B"></param>
            <param name="C"></param>
            <param name="D"></param>
            <param name="A1"></param>
            <param name="B1"></param>
            <param name="C1"></param>
            <param name="D1"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.FuncMethods.ODU.TU(МатКлассы.DRealFunc,System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},МатКлассы.DRealFunc,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Double@,System.Boolean,System.Boolean)">
            <summary>
            Решение уравнения теплопроводности явной либо неявной схемой
            </summary>
            <param name="f">Свободная фунция из уравнения</param>
            <param name="f1">Функция из первого краевого условия</param>
            <param name="f2">Функция из второго краевого условия</param>
            <param name="u0">Функция из начальных условий</param>
            <param name="u">Искомая функция (нужна для вычисления точности самого решения)</param>
            <param name="a">Коэффициент при второй производной</param>
            <param name="A1"></param>
            <param name="B1"></param>
            <param name="A2"></param>
            <param name="B2"></param>
            <param name="x0">Начало отрезка по пространству</param>
            <param name="X">Конец отрезка по пространству</param>
            <param name="t0">Начало отрезка по времени</param>
            <param name="T">Конец отрезка по времени</param>
            <param name="xcount">Число шагов по пространству</param>
            <param name="tcount">Число шагов по времени</param>
            <param name="accuracy">Выводимая точность</param>
            <param name="explict">Использовать явную схему либо нет</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Graphs">
            <summary>
            Класс графов
            </summary>
        </member>
        <member name="T:МатКлассы.Graphs.Type">
            <summary>
            Тип графа
            </summary>
        </member>
        <member name="T:МатКлассы.Graphs.Color">
            <summary>
            Перечисление цветов
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ML.HasEdge(System.Int32)">
            <summary>
            Смежно ли ребро j вершине в конце списка цепи
            </summary>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ML.Step(System.Int32)">
            <summary>
            Произвести шаг в поиске цепи
            </summary>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Graphs.Vertex">
            <summary>
            Класс вершин графа
            </summary>
        </member>
        <member name="T:МатКлассы.Graphs.Edge">
            <summary>
            Класс рёбер графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Edge.v1">
            <summary>
            Какие вершины соединяет ребро (инцидентные ребру)
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Edge.v2">
            <summary>
            Какие вершины соединяет ребро (инцидентные ребру)
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Edge.length">
            <summary>
            Длина ребра
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.Edge.#ctor(System.Int32,System.Int32)">
            <summary>
            Создать ребро по инцидентным вершинам
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:МатКлассы.Graphs.Edge.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Создать ребро по инцидентным вершинам и его длине
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="s"></param>
        </member>
        <member name="M:МатКлассы.Graphs.Edge.#ctor(МатКлассы.Graphs.Edge)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:МатКлассы.Graphs.Edge.Show">
            <summary>
            Вывести ребро на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.Edge.op_Equality(МатКлассы.Graphs.Edge,МатКлассы.Graphs.Edge)">
            <summary>
            Совпадение рёбер. Рёбра считаются совпадающими, если они имеют одинаковую длину и одинаковые концевые вершины
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.Graphs.p">
            <summary>
            Число вершин в графе
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.q">
            <summary>
            Число рёбер в графе
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.A">
            <summary>
            Матрица смежности
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.degrees">
            <summary>
            Список валетностей вершин
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Prop">
            <summary>
            Тип графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.catalogCycles">
            <summary>
            Каталог циклов
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Ver">
            <summary>
            Каталог вершин
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Ed">
            <summary>
            Каталог рёбер
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Chains">
            <summary>
            Каталог простых цепей
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Routes">
            <summary>
            Каталог маршрутов
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.IndepSubsets">
            <summary>
            Список независимых подмножеств вершин графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.GreatestIndepSubsets">
            <summary>
            Список максимальных независимых вершин подмножества
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.DominSubsets">
            <summary>
            Список доминирующих подмножеств
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MinimalDominSubsets">
            <summary>
            Список минимальных доминирующих подмножеств
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.DominationNumber">
            <summary>
            Число доминирования
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.VCoatingNumber">
            <summary>
            Число вершинного покрытия
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.ECoatingNumber">
            <summary>
            Число рёберного покрытия
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.CliquesNumber">
            <summary>
            Число кликового покрытия
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MatchingNumber">
            <summary>
            Число паросочетаний
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.Kernel">
            <summary>
            Ядро графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.VCoatingSubsets">
            <summary>
            Список вершинных покрытий
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MinimalVCoatingSubsets">
            <summary>
            Список минимальных вершинных покрытий
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.ECoatingSubsets">
            <summary>
            Список рёберных покрытий
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MinimalECoatingSubsets">
            <summary>
            Список минимальных рёберных покрытий
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.CliquesSubsets">
            <summary>
            Множества клик графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MaximalCliquesSubsets">
            <summary>
            Множество максимальных клик графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.GreatestCliquesSubsets">
            <summary>
            Множество наибольших клик графа
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MatchingSubsets">
            <summary>
            Список паросочетаний
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.MaximalMatchingSubsets">
            <summary>
            Список максимальных паросочетаний
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.GreatestMatchingSubsets">
            <summary>
            Список наибольших паросочетаний
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.EulerCycles">
            <summary>
            Эйлеровы циклы
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.EulerChains">
            <summary>
            Эйлеровы цепи
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.K5">
            <summary>
            Полный граф с 5 вершинами
            </summary>
        </member>
        <member name="F:МатКлассы.Graphs.K3_3">
            <summary>
            Полный двудольный граф K(3,3)
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.Int32)">
            <summary>
            Пустой граф указанной размерности
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.Int32,МатКлассы.Graphs.Type)">
            <summary>
            Граф указанной размерности по типу
            </summary>
            <param name="n"></param>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(МатКлассы.Graphs)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="G"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(МатКлассы.SqMatrix)">
            <summary>
            Конструктор по матрице смежности
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.IO.StreamReader)">
            <summary>
            Конструктор по матрице смежности, расположенной в файле
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.Int32,МатКлассы.Graphs.Edge[])">
            <summary>
            Создание графа по количеству вершин и набору рёбер
            </summary>
            <param name="n"></param>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.Int32,System.Collections.Generic.List{МатКлассы.Graphs.Edge})">
            <summary>
            Создание графа по количеству вершин и списку рёбер
            </summary>
            <param name="n"></param>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.Graphs.#ctor(System.Int32[])">
            <summary>
            Полный k-дольный граф
            </summary>
            <param name="k"></param>
        </member>
        <member name="P:МатКлассы.Graphs.Deg">
            <summary>
            Вектор валетностей графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.P">
            <summary>
            Вектор передаточных чисел
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Kirhg">
            <summary>
            Матрица Кирхгофа данного графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Edges">
            <summary>
            Число рёбер в графе
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Addition">
            <summary>
            Дополнительный граф
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Graphs.Acces">
            <summary>
            Матрица достижимости графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.SetOfEdges">
            <summary>
            Список рёбер графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.B">
            <summary>
            Матрица инцидентности графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Dist">
            <summary>
            Матрица расстояний связного графа
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsCvasFull(МатКлассы.SqMatrix)">
            <summary>
            Содержит ли матрица нули где-то вне главной диагонали
            </summary>
            <param name="S"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Distance(System.Int32,System.Int32)">
            <summary>
            Расстояние между двумя вершинами
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Graphs.Eccentricity">
            <summary>
            Вектор эксцентриситетов
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Radius">
            <summary>
            Радиус графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Diameter">
            <summary>
            Диаметр графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Center">
            <summary>
            Номер вершины, которую можно взять за центр графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.G">
            <summary>
            Обхват графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.C">
            <summary>
            Окружение графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Peripherys">
            <summary>
            Периферии графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Medians">
            <summary>
            Медианы графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.ComponCount">
            <summary>
            Число компонент связности
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.CyclomaticN">
            <summary>
            Цикломатическое число
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Bridges">
            <summary>
            Список мостов
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.JointPoints">
            <summary>
            Список точек сочленения
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.JointVect">
            <summary>
            Вектор точек сочленения
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Lambda">
            <summary>
            Реберная связность
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Kappa">
            <summary>
            Вершинная связность
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.ChromaticNumber">
            <summary>
            Хроматическое число графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.Density">
            <summary>
            Плотность графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.CliquesMatrix">
            <summary>
            Матрица кликов графа
            </summary>
        </member>
        <member name="P:МатКлассы.Graphs.CliquesGraph">
            <summary>
            Граф клик исходного графа
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ChainsNotCroosedEdges(System.Int32,System.Int32)">
            <summary>
            Список непересекающихся по рёбрам путей из i в j
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
            <remarks>Вершины в аргументах считаются с нуля</remarks>
        </member>
        <member name="M:МатКлассы.Graphs.ChainsNotCroosedVertex(System.Int32,System.Int32)">
            <summary>
            Список непересекающихся по вершинам путей из i в j
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
            <remarks>Вершины в аргументах считаются с нуля</remarks>
        </member>
        <member name="M:МатКлассы.Graphs.GenerateCatalogs">
            <summary>
            Заполнить каталоги
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.DominSub">
            <summary>
            Сгенерировать список доминирующих множеств
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.VCoatingSub">
            <summary>
            Сгенерировать список вершинных покрытий
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.CliquesSub">
            <summary>
            Сгенерировать список кликов графа
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.MatchingSub">
            <summary>
            Сгенерировать список паросочетаний
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.NumberEd(System.Int32,System.Int32)">
            <summary>
            Номер ребра, соответствующего заданному элементу матрицы смежности
            </summary>
            <param name="ii"></param>
            <param name="jj"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Isomorphism(МатКлассы.Graphs,МатКлассы.Graphs)">
            <summary>
            Проверка на изоморфизм графов
            </summary>
            <param name="Q"></param>
            <param name="W"></param>
            <returns>True, если граф связен</returns>
        </member>
        <member name="M:МатКлассы.Graphs.Connectivity(МатКлассы.Graphs)">
            <summary>
            Проверка на связность графа
            </summary>
            <param name="Q"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.CountN(МатКлассы.Graphs)">
            <summary>
            Число вершин графа с нечётными степенями
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Gomeomorphism(МатКлассы.Graphs,МатКлассы.Graphs)">
            <summary>
            Гомеоморфизм графов
            </summary>
            <param name="Q"></param>
            <param name="W"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.GomeoExample">
            <summary>
            Пример графа, гомеоморфного данному (посередине ребра поставлена вершина степени 2)
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.OrigExample">
            <summary>
            Пример первообразного графа (вершина степени 2 заменена ребром)
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsFull(МатКлассы.Graphs)">
            <summary>
            Полнота графа
            </summary>
            <param name="E"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsRegular(МатКлассы.Graphs)">
            <summary>
            Регулярность графа
            </summary>
            <param name="E"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsSelfAdditional(МатКлассы.Graphs)">
            <summary>
            Самодополнительность графа
            </summary>
            <param name="E"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Chain(System.Int32,System.Int32)">
            <summary>
            Вывести кратчайшую цепь между двумя вершинами (Алгоритм Дейкстры)
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <returns>Вектор как перечисление вершин в цикле, но отчёт вершин начинается с первой</returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsChain(System.String)">
            <summary>
            Является ли маршрут цепью
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsSimpleChain(System.String)">
            <summary>
            Является ли маршрут простой цепью
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsCycle(System.String)">
            <summary>
            Является ли маршрут циклом
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ShowAllCycles">
            <summary>
            Вывести все простые циклы в графе
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsAcyclic">
            <summary>
            Является ли граф ациклическим
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.GetCycleExample(System.Int32)">
            <summary>
            Вывести один цикл указанной длины
            </summary>
            <param name="t"></param>
            <returns>Цикл указанной длины или нулевой вектор в случае отсутствия такого цикла</returns>
        </member>
        <member name="M:МатКлассы.Graphs.ShowAllCycles(System.Int32)">
            <summary>
            Вывести на консоль все простые циклы указанной длины либо сообщение об их отсутствии
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.Graphs.ShowCycles(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Вывести все циклы, исходящие из массива цветов
            </summary>
            <param name="c"></param>
            <param name="r"></param>
        </member>
        <member name="M:МатКлассы.Graphs.IsBichromatic(МатКлассы.Vectors@)">
            <summary>
            Является ли граф двудольным
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.KoenigTheorem">
            <summary>
            Результат теоремы Кёнига
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.CompCount(МатКлассы.Vectors@)">
            <summary>
            Число компонент связности
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Additional(МатКлассы.Graphs)">
            <summary>
            Дополнение графа
            </summary>
            <param name="E"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.SubGraph(System.Int32[])">
            <summary>
            Граф, порождённый вершинами из массива k
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.SubGraph(МатКлассы.Vectors)">
            <summary>
            Граф, порождённый вершинами вектора
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.DeleteVertexes(System.Int32[])">
            <summary>
            Подграф, порождённый удалением заданных вершин
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.DeleteEdges(МатКлассы.Graphs.Edge[])">
            <summary>
            Создать подграф, порождённый удалением заданных рёбер
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IncludeEdges(МатКлассы.Graphs.Edge[])">
            <summary>
            Создать граф добавлением заданных рёбер
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.GetSpanningTree">
            <summary>
            Пример остова в графе (создаётся разрушением циклов)
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsTree(МатКлассы.Graphs)">
            <summary>
            Является ли граф деревом
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Pryufer(МатКлассы.Graphs)">
            <summary>
            Код Прюфера для дерева
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.PryuferUnpacking(МатКлассы.Vectors)">
            <summary>
            Распаковка кода Прюфера
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ContainThisEdge(МатКлассы.Graphs.Edge)">
            <summary>
            Сожержится ли в графе заданное ребро
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.GetNumderOfEdge(МатКлассы.Graphs.Edge)">
            <summary>
            Выдать номер ребра в каталоге рёбер
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.FundamentalCycles(МатКлассы.Graphs)">
            <summary>
            Матрица фундаментальных циклов относительно выбранного остова
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.BasisSection(МатКлассы.Matrix)">
            <summary>
            Матрица фундаментальных разрезов
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ContainEdge(System.String,МатКлассы.Graphs.Edge)">
            <summary>
            Содержит ли цепь/цикл ребро
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ContainVer(System.String,System.Int32)">
            <summary>
            Содержит ли цепь/цикл вершину
            </summary>
            <param name="s"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ContainEdgeUnique(System.String,МатКлассы.Graphs.Edge)">
            <summary>
            Содержит ли цепь/цикл ребро только единожды
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ContainVerUnique(System.String,System.Int32)">
            <summary>
            Содержит ли цепь/цикл вершину только единожды
            </summary>
            <param name="s"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.BridgeBlocks">
            <summary>
            Объединение мостов-блоков графа (исходный граф без мостов)
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.JointBlock">
            <summary>
            Граф блоков-точек сочленения (максимальный подграф без точек сочленения)
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.AboutPlanarity">
            <summary>
            Исследование графа на планарность
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.FillEuler">
            <summary>
            Сгенерировать все эйлеровы циклы и цепи
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsEuler">
            <summary>
            Проверка графа на наличие эйлерова цикла/цепи с выводом
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsHamilton">
            <summary>
            Проверка графа на наличие гамильтонова цикла/цепи с выводом
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IndependenceNumber(МатКлассы.Vectors@)">
            <summary>
            Число независимости графа
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ShowIndepSubSets">
            <summary>
            Вывести все независимые подмножетсва вершин
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ShowGreatestIndepSubSets">
            <summary>
            Вывести все наибольшие независимые подмножества
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.GetColouring">
            <summary>
            Выдать вектор раскраски графа
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.SortDeg(System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Отсортировать вершины по невозврастанию их валентностей
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:МатКлассы.Graphs.GetModifColouring">
            <summary>
            Выдать вектор (предположительно) минимальной раскраски графа (алгоритм с двухшаговыми степенями)
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.EstimateChromaticNumder">
            <summary>
            Дать оценки хроматическому числу
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsNulle(МатКлассы.Graphs)">
            <summary>
            Является ли граф пустым
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.Xpolymon">
            <summary>
            Хроматический полином графа
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ShowDominSub(System.Int32)">
            <summary>
            Показать доминирующие подмножества вершин с шагом step
            </summary>
            <param name="step"></param>
        </member>
        <member name="M:МатКлассы.Graphs.ShowMinDominSub">
            <summary>
            Показать минимальные доминирующие подмножества вершин
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ShowSmallestDominSub">
            <summary>
            Показать наименьшие доминирующие подмножества
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ShowVectorsList(System.Collections.Generic.List{МатКлассы.Vectors})">
            <summary>
            Показать список векторов
            </summary>
            <param name="L"></param>
        </member>
        <member name="M:МатКлассы.Graphs.ShowVectorsList(System.Collections.Generic.List{МатКлассы.Vectors},System.Int32)">
            <summary>
            Показать список векторов с шагом по списку
            </summary>
            <param name="L"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.Graphs.ShowEdgeListofL(System.Collections.Generic.List{System.Collections.Generic.List{МатКлассы.Graphs.Edge}},System.Int32)">
            <summary>
            Показать список рёбер с шагом по списку
            </summary>
            <param name="L"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.Graphs.ShowSmallestVCoatingSub">
            <summary>
            Показать наименьшие вершинные покрытия
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ShowSmallestECoatingSub">
            <summary>
            Показать наименьшие рёберные покрытия
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.IsIncidental(МатКлассы.Graphs.Edge,System.Int32)">
            <summary>
            Являются ли ребро и вершина инцидентными друг другу
            </summary>
            <param name="e"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsVertexCoating(System.Collections.Generic.List{System.Int32})">
            <summary>
            Образует ли множество вершинное покрытие
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.IsEdgeCoating(System.Collections.Generic.List{МатКлассы.Graphs.Edge})">
            <summary>
            Образует ли множество рёберное покрытие
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Graphs.ShowInfoConsole">
            <summary>
            Показать информацию о графе в консоли
            </summary>
        </member>
        <member name="M:МатКлассы.Graphs.ShowInfoFile">
            <summary>
            Вывести информацию о графе в файл
            </summary>
        </member>
        <member name="T:МатКлассы.Idup`1">
            <summary>
            Интерфейс наличия дубликата как метода-свойства
            </summary>
        </member>
        <member name="T:МатКлассы.Line2D">
            <summary>
            Класс прямых на плоскости (Ax+By+C=0)
            </summary>
        </member>
        <member name="F:МатКлассы.Line2D.A">
            <summary>
            Коэффициент при X
            </summary>
        </member>
        <member name="F:МатКлассы.Line2D.B">
            <summary>
            Коэффициент при Y
            </summary>
        </member>
        <member name="F:МатКлассы.Line2D.C">
            <summary>
            Свободный коэффициент
            </summary>
        </member>
        <member name="T:МатКлассы.Line2D.Type">
            <summary>
            Тип прямой
            </summary>
        </member>
        <member name="P:МатКлассы.Line2D.LineType">
            <summary>
            Тип прямой
            </summary>
        </member>
        <member name="T:МатКлассы.Line2D.Mode">
            <summary>
            Тип взаимного отношения прямых
            </summary>
        </member>
        <member name="T:МатКлассы.Line2D.EquType">
            <summary>
            Тип уравнения прямой
            </summary>
        </member>
        <member name="P:МатКлассы.Line2D.Corner_k">
            <summary>
            Тангенс угла наклона
            </summary>
        </member>
        <member name="M:МатКлассы.Line2D.#ctor(System.Double,System.Double,System.Double,МатКлассы.Line2D.EquType)">
            <summary>
            Задать прямую по её коэффициентам из уравнения ax+by+c=0
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Line2D.#ctor(МатКлассы.Point,МатКлассы.Point,МатКлассы.Line2D.EquType)">
            <summary>
            Задать прямую проходящую через две точки
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="M:МатКлассы.Line2D.#ctor(МатКлассы.Line2D,МатКлассы.Point,МатКлассы.Line2D.Mode,МатКлассы.Line2D.EquType)">
            <summary>
            Задать прямую, находящуюся относительно указанной прямой и указанной точки в заданном соотношении
            </summary>
            <param name="line"></param>
            <param name="p"></param>
            <param name="m"></param>
        </member>
        <member name="M:МатКлассы.Line2D.#ctor(System.Double,System.Double,МатКлассы.Line2D.EquType)">
            <summary>
            Задать прямую через коэффициенты уравнения из y=ax+b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.Line2D.#ctor(МатКлассы.Line2D)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="l"></param>
        </member>
        <member name="P:МатКлассы.Line2D.Func">
            <summary>
            Функция, соответствующая прямой, от аргумента x, кроме того случая, когда B=0
            </summary>
        </member>
        <member name="M:МатКлассы.Line2D.InterSecPoint(МатКлассы.Line2D,МатКлассы.Line2D)">
            <summary>
            Точка пересечения двух прямых либо null, когда прямые не пересекаются или совпадают
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Line2D.Corner(МатКлассы.Line2D,МатКлассы.Line2D)">
            <summary>
            Угол между прямыми
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Line2D.Distance(МатКлассы.Point)">
            <summary>
            Расстояние от точки до прямой
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Matrix">
            <summary>
            Произвольных размеров матрицы
            </summary>
        </member>
        <member name="F:МатКлассы.Matrix.m">
            <summary>
            Число столбцов в матрице
            </summary>
        </member>
        <member name="F:МатКлассы.Matrix.n">
            <summary>
            Число строк в матрице
            </summary>
        </member>
        <member name="F:МатКлассы.Matrix.matrix">
            <summary>
            Массив, отождествлённый с матрицей
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.Item(System.Int32,System.Int32)">
            <summary>
            Обращение к матрице как к двумерному массиву
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Matrix.Item(System.Int32)">
            <summary>
            Обращение к матрице как к одномерному массиву (при условии, что в ней число строк либо число столбцов равно 1)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Matrix.RowCount">
            <summary>
            Количество строк в матрице
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.ColCount">
            <summary>
            Количество столбцов в матрице
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor">
            <summary>
            Матрица (0)
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.Int32)">
            <summary>
            Квадратная нулевая матрица
            </summary>
            <param name="n">Размерность матрицы</param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Прямоугольная нулевая матрица
            </summary>
            <param name="n">Число строк</param>
            <param name="m"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.IO.StreamReader)">
            <summary>
            Матрица из файла
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(МатКлассы.Vectors[])">
            <summary>
            Генерировние матрицы по массиву её строк
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.Double[])">
            <summary>
            Создать матрицу как вектор-столбец
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(МатКлассы.Matrix)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Матрица по двумерному массиву
            </summary>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Создать матрицу по её размерности и массиву диагональных элементов
            </summary>
            <param name="mas"></param>
            <param name="m">Число строк</param>
            <param name="n">Число столбцов</param>
        </member>
        <member name="M:МатКлассы.Matrix.#ctor(МатКлассы.Vectors)">
            <summary>
            Преобразовать вектор в матрицу
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.Matrix.CreateMatrix">
            <summary>
            Задание матрицы с помощью консоли
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.PrintMatrix">
            <summary>
            Вывести матрицу на консоль
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.NullValue">
            <summary>
            Число нулей в матрице
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.Nulle">
            <summary>
            Нулевая ли матрица?
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.LinesDiff(System.Int32,System.Int32,System.Double)">
            <summary>
            Отнять от строки матрицы другую строку (i-k*j)
            </summary>
            <param name="i">Номер строки, от которой отнимают</param>
            <param name="j">Номер строки, которая отнимается</param>
            <param name="val">Коэффициент, на который умножается отнимаемая строка</param>
        </member>
        <member name="M:МатКлассы.Matrix.MinusVector(System.Int32,МатКлассы.Vectors)">
            <summary>
            Отнять от строки матрицы вектор
            </summary>
            <param name="i"></param>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Matrix.LinesSwap(System.Int32,System.Int32)">
            <summary>
            Переставить строки
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="M:МатКлассы.Matrix.ColumnSwap(System.Int32,System.Int32)">
            <summary>
            Переставить столбцы
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="M:МатКлассы.Matrix.ColumnDelete(System.Int32)">
            <summary>
            Удалить столбец матрицы
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.Transpose(МатКлассы.Matrix)">
            <summary>
            Транспонирование матрицы
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.Transpose">
            <summary>
            Возврат транспонированной матрицы
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Matrix.Frobenius">
            <summary>
            Норма Фробениуса
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.GetLine(System.Int32)">
            <summary>
            Перевести строку матрицы в вектор
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.GetLineString(System.Int32)">
            <summary>
            Получить строку матрицы в строковом формате
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.GetLine(System.Int32,System.Int32,System.Int32)">
            <summary>
            Перевести строку матрицы в вектор
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.AddByLine(System.Int32,System.Double)">
            <summary>
            Прибавить ко всеми элементам строки число
            </summary>
            <param name="line">Номер строки</param>
            <param name="val">Число, которое прибавляется</param>
        </member>
        <member name="M:МатКлассы.Matrix.AddByColumn(System.Int32,System.Double)">
            <summary>
            Прибавить ко всем элементам столбца число
            </summary>
            <param name="col">Номер столбца</param>
            <param name="val"></param>
        </member>
        <member name="M:МатКлассы.Matrix.DivByLine(System.Int32,System.Double)">
            <summary>
            Поделить строку в матрице на число
            </summary>
            <param name="i"></param>
            <param name="val"></param>
        </member>
        <member name="P:МатКлассы.Matrix.CubeNorm">
            <summary>
            Кубическая норма
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.OctNorn">
            <summary>
            Октаэдрическая норма
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.MaxofMod">
            <summary>
            Максимальная абсолютная величина в матрице
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.SVD(МатКлассы.Matrix,МатКлассы.Matrix@,System.Double[]@,МатКлассы.Matrix@)">
            <summary>
            Сингулярное разложение матрицы через библиотеку alglib
            </summary>
            <param name="A">Исходная матрица</param>
            <param name="U">Левая матрица</param>
            <param name="w">Вектор сингулярных чисел</param>
            <param name="VT">Правая матрица</param>
        </member>
        <member name="M:МатКлассы.Matrix.FastMult(МатКлассы.Matrix,МатКлассы.Vectors)">
            <summary>
            Умножение матрицы на вектор с использованием распараллеливания
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Matrix.Create(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Создать матрицу по стобцам
            </summary>
            <param name="a">Вектор чисел, на которые умножается эталонный столбец</param>
            <param name="v">Вектор, ставящийся в столбец</param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Matrix.Sum">
            <summary>
            Сумма элементов матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.Range">
            <summary>
            Размах элементов в матрице
            </summary>
        </member>
        <member name="P:МатКлассы.Matrix.Center">
            <summary>
            Среднее арифметическое элементов матрицы
            </summary>
        </member>
        <member name="M:МатКлассы.Matrix.Create(МатКлассы.Vectors,System.Int32,System.Boolean)">
            <summary>
            Создать матрицу по вектору
            </summary>
            <param name="v"></param>
            <param name="dim">Число строк или столбцов в зависимости от col</param>
            <param name="col">Если true, заполняются сначала строки матрицы, иначе --- столбцы</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Memoize`2">
            <summary>
            Мемоизированная функция
            </summary>
            <typeparam name="TVal">Класс аргумента</typeparam>
            <typeparam name="TResult">Класс результата</typeparam>
        </member>
        <member name="F:МатКлассы.Memoize`2.dic">
            <summary>
            Текущий словарь
            </summary>
        </member>
        <member name="P:МатКлассы.Memoize`2.Lenght">
            <summary>
            Число элементов в словаре
            </summary>
        </member>
        <member name="M:МатКлассы.Memoize`2.ShowSizeInfo">
            <summary>
            Вывести информацию у размерах словаря
            </summary>
        </member>
        <member name="M:МатКлассы.Memoize`2.OnlyAdd(`0,`1)">
            <summary>
            Только добавить значение в словарь (по идее это должно быть быстрее, чем GetOrAdd)
            </summary>
            <param name="val"></param>
            <param name="res"></param>
        </member>
        <member name="M:МатКлассы.Memoize`2.Dispose">
            <summary>
            Очистить словарь
            </summary>
        </member>
        <member name="M:МатКлассы.Memoize`2.#ctor(System.Func{`0,`1},System.Int32,System.Int32)">
            <summary>
            Конструктор по обычной функции
            </summary>
            <param name="Memoize">Исходная функция</param>
            <param name="capacity">Начальная ёмкость</param>
            <param name="concurrencyLevel">Уровень параллелизма</param>
        </member>
        <member name="P:МатКлассы.Memoize`2.Value">
            <summary>
            Делегат, возвращающий оптимизированную за счёт мемоизации функцию
            </summary>
        </member>
        <member name="T:МатКлассы.MemoizeNotConcurrent`2">
            <summary>
            Мемоизированная функция (через Dictionary, а не ConcurrentDictionary)
            </summary>
            <typeparam name="TVal">Класс аргумента</typeparam>
            <typeparam name="TResult">Класс результата</typeparam>
            <remarks>Есть инфа, что извлечение из Dictionary в два раза быстрее, чем из ConcurrentDictionary, так что иногда этот класс будет предпочтительнее</remarks>
        </member>
        <member name="F:МатКлассы.MemoizeNotConcurrent`2.dic">
            <summary>
            Текущий словарь
            </summary>
        </member>
        <member name="P:МатКлассы.MemoizeNotConcurrent`2.Lenght">
            <summary>
            Число элементов в словаре
            </summary>
        </member>
        <member name="M:МатКлассы.MemoizeNotConcurrent`2.OnlyAdd(`0,`1)">
            <summary>
            Только добавить значение в словарь (по идее это должно быть быстрее, чем GetOrAdd)
            </summary>
            <param name="val"></param>
            <param name="res"></param>
        </member>
        <member name="M:МатКлассы.MemoizeNotConcurrent`2.Dispose">
            <summary>
            Очистить словарь
            </summary>
        </member>
        <member name="M:МатКлассы.MemoizeNotConcurrent`2.#ctor(System.Func{`0,`1},System.Int32)">
            <summary>
            Конструктор по обычной функции
            </summary>
            <param name="Memoize">Исходная функция</param>
            <param name="capacity">Начальная ёмкость</param>
        </member>
        <member name="P:МатКлассы.MemoizeNotConcurrent`2.Value">
            <summary>
            Делегат, возвращающий оптимизированную за счёт мемоизации функцию
            </summary>
        </member>
        <member name="T:МатКлассы.MultipleKnot">
            <summary>
            Класс кратных узлов
            </summary>
        </member>
        <member name="F:МатКлассы.MultipleKnot.x">
            <summary>
            Абцисса кратного узла
            </summary>
        </member>
        <member name="F:МатКлассы.MultipleKnot.y">
            <summary>
            Массив ординат кратного узла
            </summary>
        </member>
        <member name="M:МатКлассы.MultipleKnot.#ctor(System.Double,System.Double[])">
            <summary>
            Полный конструктор
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="P:МатКлассы.MultipleKnot.Multiplicity">
            <summary>
            Кратность узла
            </summary>
        </member>
        <member name="T:МатКлассы.NetOnDouble">
            <summary>
            Сетка на отрезке действительной оси
            </summary>
        </member>
        <member name="F:МатКлассы.NetOnDouble.Begin">
            <summary>
            Начало отрезка
            </summary>
        </member>
        <member name="F:МатКлассы.NetOnDouble.End">
            <summary>
            Конец отрезка
            </summary>
        </member>
        <member name="F:МатКлассы.NetOnDouble.Count">
            <summary>
            Число точек в сетке (включая начало отрезка и конец, второе если WithEnd=true)
            </summary>
        </member>
        <member name="F:МатКлассы.NetOnDouble.Step">
            <summary>
            Шаг по отрезку, расстояние между соседними точками
            </summary>
        </member>
        <member name="F:МатКлассы.NetOnDouble.WithEnd">
            <summary>
            Флаг, указывающий, содержит ли сетка конец отрезка
            </summary>
        </member>
        <member name="M:МатКлассы.NetOnDouble.#ctor(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Создать сетку по параметрам
            </summary>
            <param name="begin">Начало отрезка</param>
            <param name="end">Конец отрезка</param>
            <param name="count">Число точек в сетке</param>
            <param name="withend">Включать ли конец отрезка в сетку</param>
        </member>
        <member name="M:МатКлассы.NetOnDouble.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Создать отрезок по концам и шагу
            </summary>
            <param name="begin">Начало отрезка</param>
            <param name="end">Конец отрезка</param>
            <param name="step">Шаг</param>
        </member>
        <member name="M:МатКлассы.NetOnDouble.#ctor(МатКлассы.NetOnDouble,System.Int32)">
            <summary>
            Копия сетки, но с другим числом узлов
            </summary>
            <param name="netOnDouble"></param>
            <param name="newCount"></param>
        </member>
        <member name="P:МатКлассы.NetOnDouble.Array">
            <summary>
            Сам массив сетки
            </summary>
        </member>
        <member name="P:МатКлассы.NetOnDouble.Range">
            <summary>
            Длина отрезка для сетки
            </summary>
        </member>
        <member name="P:МатКлассы.NetOnDouble.Center">
            <summary>
            Середина отрезка
            </summary>
        </member>
        <member name="T:МатКлассы.Number">
            <summary>
            Числовые классы
            </summary>
        </member>
        <member name="T:МатКлассы.Number.Complex">
            <summary>
            Комплексные числа
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Complex._2PI">
            <summary>
            2 * pi
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Complex.I">
            <summary>
            Мнимая единица
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Complex._2I">
            <summary>
            Две мнимые единицы
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Complex.fracI2">
            <summary>
            I/2
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Complex.dup">
            <summary>
            Дубликат комплексного числа (нужен, чтобы делать дубликаты массивов)
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Complex.#ctor(System.Double)">
            <summary>
            По действительному числу составить комплексное
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Number.Complex.#ctor(System.Double,System.Double)">
            <summary>
            Составить комплексное число по паре действительных чисел
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.Number.Complex.#ctor(МатКлассы.Number.Complex)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="p"></param>
        </member>
        <member name="P:МатКлассы.Number.Complex.Re">
            <summary>
            Действительная часть
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Complex.Im">
            <summary>
            Мнимая часть
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Complex.Abs">
            <summary>
            Модуль
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Complex.Arg">
            <summary>
            Аргумент
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Complex.Imag(МатКлассы.Number.Complex)">
            <summary>
            Мнимая часть комплексного числа (нужно для интегрирования, портированного с Fortran)
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Number.Complex.Conjugate">
            <summary>
            Комплексно-сопряжённое число
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.ToString">
            <summary>
            Перевести в строку вида a+bi
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.op_Implicit(System.Double)~МатКлассы.Number.Complex">
            <summary>
            Неявное преобразование действительного числа в комплексное
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Number.Complex.op_Implicit(System.Int32)~МатКлассы.Number.Complex">
            <summary>
            Неявное преобразование натурального числа в комплексное
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Number.Complex.op_Explicit(МатКлассы.Number.Complex)~System.Double">
            <summary>
            Явное преобразование комплексного числа в действительное (в модуль)
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Number.Complex.Equals(System.Object)">
            <summary>
            Совпадение комплексных чисел
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Sum(МатКлассы.Number.Complex[],МатКлассы.Number.Complex)">
            <summary>
            Сумма комплексного вектора с постоянным комклексным числом(покомпонентное сложение)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Sum(МатКлассы.Number.Complex[],МатКлассы.Number.Complex[])">
            <summary>
            Сумма комплексных векторов
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Mult(МатКлассы.Number.Complex,МатКлассы.Number.Complex[])">
            <summary>
            Произведение комплексного вектора на число
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Mult(МатКлассы.Number.Complex,System.Double[])">
            <summary>
            Произведение действительного вектора на комплексное число
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.ToComplexMas(System.Double[])">
            <summary>
            Перевод действительного массива в конмплексный
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.VectorNorm(МатКлассы.Number.Complex[])">
            <summary>
            Сумма модулей массива
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Expi(System.Double)">
            <summary>
            expi(x) = cos(x) + i sin(x)
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Exp(МатКлассы.Number.Complex)">
            <summary>
            Комплексная экспонента
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Sin(МатКлассы.Number.Complex)">
            <summary>
            Комплексный синус
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Cos(МатКлассы.Number.Complex)">
            <summary>
            Комплексный косинус
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Radical(МатКлассы.Number.Complex,System.Int32)">
            <summary>
            Многозначный радикал
            </summary>
            <param name="z"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Radicalk(МатКлассы.Number.Complex,System.Int32)">
            <summary>
            Главное значение радикала
            </summary>
            <param name="z"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Sqrt(МатКлассы.Number.Complex)">
            <summary>
            Главное значение квадратного корня
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.SqrtSig(МатКлассы.Number.Complex)">
            <summary>
            Главное значение квадратного корня, умноженное на sign(Im)
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Number.Complex.Swap">
            <summary>
            Поменять мнимую и действительную часть местами, выведя результат
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Complex.Pow(МатКлассы.Number.Complex,System.Int32)">
            <summary>
            Возведение в степень
            </summary>
            <param name="z"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Pow(МатКлассы.Number.Complex,System.Double)">
            <summary>
            Возведение в степень
            </summary>
            <param name="z"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Sh(МатКлассы.Number.Complex)">
            <summary>
            Гиперболический синус
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Ch(МатКлассы.Number.Complex)">
            <summary>
            Гиперболический косинус
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Complex.Cth(МатКлассы.Number.Complex,System.Double)">
            <summary>
            Гиперболический котангенс
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Number.Complex.ComplMode">
            <summary>
            Способ отображения комплексного числа в действительное
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Complex.ReIm">
            <summary>
            Сумма действительной и мнимой части
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Complex.MoveTo(МатКлассы.Number.Complex)">
            <summary>
            Заменить комплексное число на другое
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.Number.ReImAbs(МатКлассы.Number.Complex[])">
            <summary>
            Возвращает действительную, мнимую части и модули массива
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Number.Rational">
            <summary>
            Рациональные числа (числа, представимые в виде m/n)
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Rational.Numerator">
            <summary>
            Делимое
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Rational.Denominator">
            <summary>
            Делитель
            </summary>
        </member>
        <member name="P:МатКлассы.Number.Rational.IsNan">
            <summary>
            Сообщает, равен н
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Rational.ZERO">
            <summary>
            Ноль и единица во множестве рациональных чисел
            </summary>
        </member>
        <member name="F:МатКлассы.Number.Rational.ONE">
            <summary>
            Ноль и единица во множестве рациональных чисел
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Rational.#ctor(System.Int64)">
            <summary>
            Рациональное число по целому числу
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.#ctor(System.Int64,System.Int64)">
            <summary>
            Несократимая дробь, эквивалентная частному аргументов
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.#ctor(МатКлассы.Number.Rational)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.#ctor(System.Double)">
            <summary>
            Рациональное число по "действительному" числу
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.Nod(System.Int64,System.Int64)">
            <summary>
            Наибольший общий делитель
            </summary>
            <param name="c"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.ToString">
            <summary>
            Перевести число в строку, где число имеет вид неправильной дроби
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.ToStringMixed">
            <summary>
            Привести число в строку, где оно имеет вид смешанной дроби
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.ShowMixed">
            <summary>
            Вывести смешанную дробь
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Rational.ToRational(System.Double)">
            <summary>
            Перевод десятичного числа в несократимую дробь
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Number.Rational.IntPart">
            <summary>
            Целая часть числа
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Rational.IntegerPart(МатКлассы.Number.Rational)">
            <summary>
            Целая часть числа
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Number.Rational.FracPart">
            <summary>
            Дробная часть числа
            </summary>
        </member>
        <member name="M:МатКлассы.Number.Rational.FractPart(МатКлассы.Number.Rational)">
            <summary>
            Дробная часть числа
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.IsFractional(МатКлассы.Number.Rational)">
            <summary>
            Является ли дробным
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.IsFract">
            <summary>
            Является ли дробным
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Number.Rational.Show(System.Double)">
            <summary>
            Показать действительное число в виде смешанной дроби
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.Show(МатКлассы.Number.Rational)">
            <summary>
            Показать рациональное число в виде смешанной дроби
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Number.Rational.Show(МатКлассы.Number.Complex)">
            <summary>
            Показать комплексное число с рациональными частями
            </summary>
            <param name="a"></param>
        </member>
        <member name="T:МатКлассы.Parser">
            <summary>
            Парсер для перевода формулы функции в делегат
            </summary>
        </member>
        <member name="P:МатКлассы.Parser.FORMULA">
            <summary>
            Последняя отредактированная формула, по которой построился делегат
            </summary>
        </member>
        <member name="M:МатКлассы.Parser.#ctor(System.String)">
            <summary>
            Конструктор для выражений без переменных (переменная считается нулевой)
            </summary>
            <param name="str">Строка формулы</param>
        </member>
        <member name="P:МатКлассы.Parser.INFORMATION">
            <summary>
            Информация о том, какие функции считываются при парсинге и как и пользоваться
            </summary>
        </member>
        <member name="M:МатКлассы.Parser.#ctor(System.Double,System.String)">
            <summary>
            Конструктор для выражений с переменными (переменная x)
            </summary>
            <param name="x">Значение переменной</param>
            <param name="str">Строка формулы</param>
        </member>
        <member name="M:МатКлассы.Parser.#ctor(System.String,System.Double)">
            <summary>
            Конструктор для выражений с переменными (переменная x)
            </summary>
            <param name="x">Значение переменной</param>
            <param name="str">Строка формулы</param>
        </member>
        <member name="M:МатКлассы.Parser.GetDelegate(System.String)">
            <summary>
            Возвращает функцию по формуле этой функции, где переменной является x
            </summary>
            <param name="s">Формула функции</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Point">
            <summary>
            Точки на плоскости
            </summary>
        </member>
        <member name="F:МатКлассы.Point.Zero">
            <summary>
            Начало координат в нуле
            </summary>
        </member>
        <member name="F:МатКлассы.Point.x">
            <summary>
            Абцисса
            </summary>
        </member>
        <member name="F:МатКлассы.Point.y">
            <summary>
            Ордината
            </summary>
        </member>
        <member name="M:МатКлассы.Point.#ctor(System.Double)">
            <summary>
            Точка с одинаковыми координатами
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Point.#ctor(System.Double,System.Double)">
            <summary>
            Точка по своим координатам
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.Point.#ctor(МатКлассы.Point)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="p"></param>
        </member>
        <member name="P:МатКлассы.Point.Abs">
            <summary>
            Расстояние от точки до (0,0)
            </summary>
        </member>
        <member name="P:МатКлассы.Point.dup">
            <summary>
            Дубликат точки
            </summary>
        </member>
        <member name="P:МатКлассы.Point.Swap">
            <summary>
            Точка с переставленными координатами
            </summary>
        </member>
        <member name="M:МатКлассы.Point.Add(МатКлассы.Point,System.Double)">
            <summary>
            Добавить число к обеим координатам точки
            </summary>
            <param name="p"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Add(МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Сложить точки как вектора
            </summary>
            <param name="p"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Add(МатКлассы.Point,System.Double,System.Double)">
            <summary>
            Сместить точку
            </summary>
            <param name="p"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Center(МатКлассы.Point[])">
            <summary>
            Центр множества точек как их взвешенная сумма
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.MeanDist(МатКлассы.Point[])">
            <summary>
            Среднее расстояние от центра множества
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Eudistance(МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Евклидово расстояние между точками
            </summary>
            <param name="z"></param>
            <param name="w"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.PotentialF(МатКлассы.Point)">
            <summary>
            Значение функции базисного потенциала, связанного с этой точкой
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.BPotentialF(МатКлассы.Point)">
            <summary>
            Функция второго базисного потенциала, сцепленного с точкой z
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.GetBigRect(МатКлассы.Point[])">
            <summary>
            Возвращает координаты нижнего левого и верхнего правого угла прямоугольника, содержащего все точки массива
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.GetSequence(System.Double[])">
            <summary>
            Перевести массив чисел в последовательность точек на плоскости
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.op_Multiply(МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Скалярное произведение точек как векторов
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.op_GreaterThan(МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Сравнение точек по установленной по умолчанию упорядоченности
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Points(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Набор n+1 точек на графике функции f, разбитых равномерно на отрезке от a до b
            </summary>
            <param name="f"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Points(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
            Вывести массив точек, через которые проходит функция
            </summary>
            <param name="f">Функция, заданная на отрезке</param>
            <param name="h">Шаг обхода отрезка</param>
            <param name="a">Начало отрезка</param>
            <param name="b">Конец отрезка</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Points(System.IO.StreamReader)">
            <summary>
            Считать массив точек из файла
            </summary>
            <param name="fs"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Points(System.Func{System.Double,System.Double},System.Double[],System.Boolean)">
            <summary>
            Массив точек, через которые проходит функция, по массиву абцисс эти точек
            </summary>
            <param name="f"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Points(System.Collections.Generic.List{МатКлассы.Point})">
            <summary>
            Генерация массива точек по списку точек
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.CreatePointArray(System.Double,System.Double,System.Int32,System.String,System.String,System.Int32)">
            <summary>
            Создать массив точек со значениями из файла и с аргументами с определённой закономерностью
            </summary>
            <param name="begin">Начало отрезка по аргументам</param>
            <param name="step">Шаг по отрезкку</param>
            <param name="count">Число точек</param>
            <param name="filename">Имя файла со значениями</param>
            <param name="path">Пусть к файлу</param>
            <param name="byevery">Брать каждый какой-то элемент</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Point.Show(МатКлассы.Point[])">
            <summary>
            Показать массив точек на консоли
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:МатКлассы.Point.Show">
            <summary>
            Показать координаты точки на консоли
            </summary>
        </member>
        <member name="M:МатКлассы.Point.ToString">
            <summary>
            Строковое изображение точки
            </summary>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Polygon">
            <summary>
            Многоугольник на плоскости
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.Center">
            <summary>
            Центр многоугольника
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.Vertexes">
            <summary>
            Вершины многоугольника
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.VertCount">
            <summary>
            Количество вершин многоугольника
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.Perimeter">
            <summary>
            Периметр многоугольника
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.CutLength">
            <summary>
            Длина стороны многоугольника
            </summary>
        </member>
        <member name="P:МатКлассы.Polygon.S">
            <summary>
            Площадь многоугольника
            </summary>
        </member>
        <member name="M:МатКлассы.Polygon.#ctor(МатКлассы.Point,System.Int32,System.Double,System.Double)">
            <summary>
            Создание многоугольника по его параметрам
            </summary>
            <param name="center">Центр многоугольника</param>
            <param name="vertcount">Число вершин</param>
            <param name="sidelenght">Длина стороны</param>
            <param name="somecorner">Угол между осью Х и отрезком, соединяющим центр многоугольника с какой-то его вершиной</param>
        </member>
        <member name="M:МатКлассы.Polygon.Transfer(System.Double)">
            <summary>
            Возвращает точку на кривой в зависимости от значения естественного параметра
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Polygon.ToCurve">
            <summary>
            Перевод многоугольника в кривую по более оптимальному алгоритму, рассчитанному на интегрирование
            </summary>
        </member>
        <member name="T:МатКлассы.Polynom">
            <summary>
            Класс полиномов вида a+bx+...
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.degree">
            <summary>
            Степень полинома
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.coef">
            <summary>
            Массив коэффициентов полинома в порядке возрастания степеней
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.points">
            <summary>
            Массив точек, через которые проходит полином
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor">
            <summary>
            Никакой полином
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(МатКлассы.Polynom)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Double[])">
            <summary>
            Задать полином через массив коэффициентов
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(МатКлассы.Vectors)">
            <summary>
            Задать полином по вектору коэффициентов
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.IO.StreamReader)">
            <summary>
            Прочитать массив коэффициентов полинома из файла и задать полином
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Int32)">
            <summary>
            Нулевой полином нужной степени
            </summary>
            <param name="deg"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Double)">
            <summary>
            Приведённый одночлен по единственному корню (то есть 1(х-х0))
            </summary>
            <param name="x">Корень одночлена</param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Double,System.Double[])">
            <summary>
            Задать полином по старшему коэффициенту и набору его корней
            </summary>
            <param name="aN"></param>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Double,МатКлассы.Vectors)">
            <summary>
            Создание полинома по старшему коэффициенту и вектору корней
            </summary>
            <param name="aN"></param>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(МатКлассы.Point[])">
            <summary>
            Полином (Лагранжа), проходящий через точки массива
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:МатКлассы.Polynom.#ctor(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double)">
            <summary>
            Интерполяционный полином функции f с n+1 узлами интерполяции (значит, n-й степени) на отрезке от a до b
            </summary>
            <param name="f">Интерполируемая функция</param>
            <param name="n">Степень полинома</param>
            <param name="a">Начало отрезна интерполирования</param>
            <param name="b">Конец отрезка интерполирования</param>
        </member>
        <member name="M:МатКлассы.Polynom.SavePoints">
            <summary>
            Сохранить в массив точки, через которые проходит полином
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.W(МатКлассы.Point[])">
            <summary>
            Разделённая разность без рекурсии
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.W(МатКлассы.Point[],System.Int32,System.Int32)">
            <summary>
            Разделённая разность по массиву точек (с рекурсией)
            </summary>
            <param name="p">Массив точек</param>
            <param name="i">Номер начального элемента в разности</param>
            <param name="j">Номер конечного элемента в разности</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Value(System.Double)">
            <summary>
            Вычисление значения в точке по схеме Горнера
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Value(МатКлассы.SqMatrix)">
            <summary>
            Полином от матрицы
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Value(МатКлассы.Polynom)">
            <summary>
            Полином от полинома
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Show">
            <summary>
            Вывод полинома на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.ShowRational">
            <summary>
            Вывод полинома с рациональными коэффициентами на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.ToString">
            <summary>
            Преобразование полинома в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.ToStringRational">
            <summary>
            Преобразовать полином в строку с отображением рациональных коэффициентов
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.ToLeadPolynom">
            <summary>
            Приведённый полином по текущему полиному
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.ToLeadPolynom(МатКлассы.Polynom)">
            <summary>
            Приведённый полином такого-то полинома
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.ToPolynom(System.Double)">
            <summary>
            Перевод числа в полином нулевой степени с соответствующим коэффициентом
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.ToPolynom(System.Double[])">
            <summary>
            Перевод массива чисел в полином
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Derivative(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Полином, близкий к производной функции f порядка k
            </summary>
            <param name="f"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.CharactPol(МатКлассы.SqMatrix)">
            <summary>
            Характеристический многочлен заданной матрицы
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.AddPoint(МатКлассы.Point)">
            <summary>
            Добавить ещё одну точку, через которую проходит полином (методами Ньютона)
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.S(System.Double,System.Double)">
            <summary>
            Точное вычисление определённого интеграла по формуле Ньютона-Лейбница
            </summary>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Lag(МатКлассы.Point[])">
            <summary>
            Интерполяционных полином Лагранжа, проходящий через точки из массива p
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Lag(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double)">
            <summary>
            Интерполяционный полином функции f с n+1 узлами интерполяции (значит, n-й степени) на отрезке от a до b
            </summary>
            <param name="f"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Cheb(System.Int32,МатКлассы.Kind)">
            <summary>
            Вывод полинома Чебышёва соответсвующего рода и степени
            </summary>
            <param name="r"></param>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Lezh(System.Int32)">
            <summary>
            Полином Лежандра
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Lagerr(System.Int32)">
            <summary>
            Полиномы Лагерра
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Hermit(System.Int32)">
            <summary>
            Полиномы Эрмита (ортогональные)
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Neu(МатКлассы.Point[])">
            <summary>
            Полином Ньютона через разделённые разности по массиву точек
            </summary>
            <param name="P"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.NeuNew(МатКлассы.Point[],МатКлассы.Polynom[]@,МатКлассы.Polynom[]@)">
            <summary>
            Полином Ньютона через разделённые разности по массиву точек
            </summary>
            <param name="P"></param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.Polynom.syst">
            <summary>
            Объект для хранения вспомогательной системы
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.Rat">
            <summary>
            Строковое представление рациональной функции
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.R(МатКлассы.Point[],System.Int32,System.Int32,System.Double)">
            <summary>
            Интерполяция рациональной функцией по точкам
            </summary>
            <param name="P">Массив точек</param>
            <param name="p">Степень полинома в числителе</param>
            <param name="q">Степень полинома в знаменателе</param>
            <param name="bq">Старший коэффициент в знаменателе</param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.Polynom.SplinePol">
            <summary>
            Строковое представление сплайна (массив полиномов)
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.DSpline">
            <summary>
            Первая и вторая производные сплайна
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.D2Spline">
            <summary>
            Первая и вторая производные сплайна
            </summary>
        </member>
        <member name="F:МатКлассы.Polynom.hmax">
            <summary>
            Максимальный шаг между двумя соседними точками при интерполяции сплайном
            </summary>
        </member>
        <member name="M:МатКлассы.Polynom.CubeSpline(МатКлассы.Point[],System.Double,System.Double,System.Boolean)">
            <summary>
            Интерполяция кубическими сплайнами дефекта 1 по массиву точек
            </summary>
            <param name="P"></param>
            <param name="a">Граничное условие в начале отрезка</param>
            <param name="b">Граничное условие в конце отрезка</param>
            <param name="is0outcut">Должен ли сплайн равняться 0 вне отрезка задания</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Hermit(МатКлассы.MultipleKnot[])">
            <summary>
            Полиномы Эрмита для набора кратных узлов
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.wn(МатКлассы.Point[],System.Double,System.Double)">
            <summary>
            Оценка погрешности метода
            </summary>
            <param name="p"></param>
            <param name="x"></param>
            <param name="Mn"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.wn(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Оценка погрешности метода
            </summary>
            <param name="f"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <param name="Mn"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.LagEstimateErr(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Оценить погрешность интерполяционного полинома (Лагранжа) в точке при константе
            </summary>
            <param name="f">Интерполируемая функция</param>
            <param name="n">Стень полинома</param>
            <param name="a">Начало отрезка интерполирования</param>
            <param name="b">Конец отрезка интерполяции</param>
            <param name="x">Точка, в которой оценивается погрешность</param>
            <param name="Mn">Константа в погрешности</param>
        </member>
        <member name="M:МатКлассы.Polynom.ShowNeuNew(МатКлассы.Point[],System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Показать последовательно значение слагаемых в сумме полинома Ньютона в точке x
            </summary>
            <param name="h"></param>
            <param name="f"></param>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Polynom.ScalarP(МатКлассы.Polynom,МатКлассы.Polynom,System.Double,System.Double)">
            <summary>
            Скалярное произведение между полиномами на отрезке
            </summary>
            <param name="p"></param>
            <param name="q"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.NormL(МатКлассы.Polynom,System.Double,System.Double)">
            <summary>
            Скалярное произведение между полиномами на отрезке
            </summary>
            <param name="x"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.Distance(МатКлассы.Polynom,МатКлассы.Polynom,System.Double,System.Double)">
            <summary>
            Расстояние между полиномами на отрезке
            </summary>
            <param name="p"></param>
            <param name="q"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Polynom.PolynomTestShow(System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Показать информацию о интерполяции указанной функции методами класса полиномов
            </summary>
            <param name="f"></param>
            <param name="k">Число узлов интерполяции</param>
            <param name="a">Начало отрезка с узлами</param>
            <param name="b">Конец отрезка с узлами</param>
            <param name="p">Степень числителя у рациональной функции</param>
            <param name="q">Степень знаменателя у рациональной функции</param>
            <param name="bq">Старший коэффициент знаменателя рациональной функции</param>
        </member>
        <member name="M:МатКлассы.Polynom.PolynomTestShow(System.Func{System.Double,System.Double},System.Double[],System.Double,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Показать информацию о интерполяции указанной функции методами класса полиномов
            </summary>
            <param name="f"></param>
            <param name="c">Массив абцисс узлов интерполяции</param>
            <param name="a">Начало отрезка с узлами</param>
            <param name="b">Конец отрезка с узлами</param>
            <param name="p">Степень числителя у рациональной функции</param>
            <param name="q">Степень знаменателя у рациональной функции</param>
            <param name="bq">Старший коэффициент знаменателя рациональной функции</param>
        </member>
        <member name="T:МатКлассы.RandomNumbers">
            <summary>
            Класс, выдающий случайное число
            </summary>
        </member>
        <member name="M:МатКлассы.RandomNumbers.NextNumber">
            <summary>
            Случайное положительное число типа int
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.RandomNumbers.NextNumber(System.Int32)">
            <summary>
            Случайное число int до 0 до ceiling
            </summary>
            <param name="ceiling"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.RandomNumbers.NextDouble">
            <summary>
            Случаное число от 0 до 1
            </summary>
        </member>
        <member name="M:МатКлассы.RandomNumbers.NextDouble2(System.Double,System.Double)">
            <summary>
            Возвращает случайное число из указанного диапазона
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Roots">
            <summary>
            Класс методов поиска корней
            </summary>
        </member>
        <member name="M:МатКлассы.Roots.MyHalfc(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Простой поиск корней комплексной функции на действительном отрезке методом дихотомии
            </summary>
            <param name="f"></param>
            <param name="beg"></param>
            <param name="end"></param>
            <param name="step"></param>
            <param name="eps"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Roots.RootsByMinAbs(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Простой поиск корней как поиск минимумов модуля функции (которые должны быть равны 0)
            </summary>
            <param name="f"></param>
            <param name="beg"></param>
            <param name="end"></param>
            <param name="step"></param>
            <param name="eps"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Roots.MethodRoot">
            <summary>
            Метод локального поиска корня
            </summary>
        </member>
        <member name="F:МатКлассы.Roots.MethodRoot.Combine">
            <summary>
            Комбинация методов Brent, Secant и Broyden
            </summary>
        </member>
        <member name="M:МатКлассы.Roots.OtherMethod(МатКлассы.ComplexFunc,System.Double,System.Double,System.Double,System.Double,МатКлассы.Roots.MethodRoot,System.Boolean,System.Int32)">
            <summary>
            Поиск корней одним из специальных методов
            </summary>
            <param name="f"></param>
            <param name="beg"></param>
            <param name="end"></param>
            <param name="step"></param>
            <param name="eps"></param>
            <param name="m">Метод</param>
            <param name="withMuller">Дополнять ли корни корнями метода парабол</param>
            <param name="countpoles">Требуемое количество корней. Если это число заранее известно, его указание может сильно ускорить вычисление. Иначе надо взять большое число</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SheringFunction">
            <summary>
            Класс, создающий срезывающую функцию
            </summary>
        </member>
        <member name="M:МатКлассы.SheringFunction.GetSheringFunction(System.Double,System.Double,System.Double)">
            <summary>
            Возращает срезывающую функцию
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="delta">Чем больше, тем глаже, как мне кажется</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SheringFunction.GetSheredFunction(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
            Срезанную функцию по образцу несрезанной
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SLAU">
            <summary>
            Класс СЛАУ с методами их решения
            </summary>
        </member>
        <member name="P:МатКлассы.SLAU.Size">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="F:МатКлассы.SLAU.A">
            <summary>
            Матрица системы
            </summary>
        </member>
        <member name="F:МатКлассы.SLAU.b">
            <summary>
            Свободный вектор системы
            </summary>
        </member>
        <member name="F:МатКлассы.SLAU.x">
            <summary>
            Вектор решения
            </summary>
        </member>
        <member name="F:МатКлассы.SLAU.NEVA">
            <summary>
            Невязка решения
            </summary>
        </member>
        <member name="T:МатКлассы.SLAU.Func_in_matrix">
            <summary>
            Класс функций для элементов системы (написано в процедурном стиле, перенёс из курсача, так как матрица системы - это массив массивов)
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Matrix_power(System.Double[]@,System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
            Частичное произведение матрицы на вектор
            </summary>
            <param name="Ax"></param>
            <param name="a"></param>
            <param name="x"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Vector_difference(System.Double[]@,System.Double[],System.Double[],System.Int32)">
            <summary>
            Разность двух векторов
            </summary>
            <param name="r"></param>
            <param name="Ax"></param>
            <param name="b"></param>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Scalar_power(System.Double[],System.Double[],System.Int32)">
            <summary>
            Классическое скалярное произведение двух векторов
            </summary>
            <param name="r"></param>
            <param name="rr"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Vector_on_scalar(System.Double[]@,System.Double,System.Double[],System.Int32)">
            <summary>
            Умножение вектора на скаляр
            </summary>
            <param name="s"></param>
            <param name="tau"></param>
            <param name="r"></param>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Vector_sum(System.Double[]@,System.Double[],System.Double[],System.Int32)">
            <summary>
            Сумма векторов
            </summary>
            <param name="sum"></param>
            <param name="s"></param>
            <param name="x"></param>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Func_in_matrix.Vector_assingment(System.Double[]@,System.Double[],System.Int32)">
            <summary>
            Присваивание одному вектору другого
            </summary>
            <param name="x"></param>
            <param name="s"></param>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Nev(System.Double[0:,0:],System.Double[],System.Double[],System.Int32)">
            <summary>
            Функция частичной невязки
            </summary>
            <param name="A"></param>
            <param name="x"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SLAU.Nev(System.Int32)">
            <summary>
            Частичная невязка используемой системы
            </summary>
            <param name="t">Размерность подсистемы</param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.SLAU.Discrep">
            <summary>
            Невязка системы
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor">
            <summary>
            Конструктор по умолчанию
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(System.IO.StreamReader)">
            <summary>
            Прочитать систему из файла
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(System.Int32)">
            <summary>
            Создать нулевую систему заданной размерности
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.Matrix)">
            <summary>
            Задать систему по её расширенной матрице
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.SequenceFunc,System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,МатКлассы.SequenceFuncKind)">
            <summary>
            Создать систему, заполненную скалярными произведениями
            </summary>
            <param name="p">Функция из некоторой системы</param>
            <param name="f">Действительная функция (которую требуется аппроксимирвать)</param>
            <param name="k">Количество используемых функций системы</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.SequenceFunc,МатКлассы.FuncMethods.NetFunc,System.Int32)">
            <summary>
            Создать систему, заполненную скалярными произведениями по сетке
            </summary>
            <param name="p">Функция из некоторой системы</param>
            <param name="f">Сеточная функция (которую требуется аппроксимирвать)</param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.SequencePol,System.Func{System.Double,System.Double},System.Int32,System.Double,System.Double,МатКлассы.SequenceFuncKind)">
            <summary>
            Создать систему, заполненную скалярными произведениями
            </summary>
            <param name="p">Полином из некоторой системы</param>
            <param name="f">Действительная функция (которую требуется аппроксимирвать)</param>
            <param name="k">Количество используемых функций системы</param>
            <param name="a">Начало отрезка интегрирования</param>
            <param name="b">Конец отрезка интегрирования</param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.SLAU,System.Int32)">
            <summary>
            Создать систему как подсистему исходной системы с заданной разменостью 
            </summary>
            <param name="M"></param>
            <param name="t">Размерность подсистемы</param>
        </member>
        <member name="M:МатКлассы.SLAU.#ctor(МатКлассы.SqMatrix,МатКлассы.Vectors)">
            <summary>
            Задание СЛАУ по матрице и свободному вектору
            </summary>
            <param name="M"></param>
            <param name="b"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Make(System.Int32)">
            <summary>
            Создание двумерного и одномерных динамических массивов с заданной размерностью
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.SLAU.ProRace">
            <summary>
            Решение методом прогонки системы с трёхдиагональной матрицей
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.Gauss(System.Int32,System.Boolean)">
            <summary>
            Метод Гаусса (частичный)
            </summary>
            <param name="t">Количество строк, с которыми происходит преобразование</param>
            <param name="getdiv">Надо ли делить на среднее по модулю в строке</param>
        </member>
        <member name="M:МатКлассы.SLAU.Gauss">
            <summary>
            Стандартный метод Гаусса
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.GaussSelection">
            <summary>
            Метод Гаусса, годный и при нулевых коэффициентах в системе
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.Holets(System.Int32)">
            <summary>
            Решение уравнения Ах=b методом Холецкого, присвоение вектору х значений решения
            </summary>
            <param name="z"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Jak(System.Int32,System.Double,System.Int32)">
            <summary>
            Решение уравнения Ах=b методом Якоби (простой итерации), присвоение вектору х значений решения
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Speedy(System.Int32,System.Double,System.Int32)">
            <summary>
            Метод наискорейшего спуска со свободным вектором в качестве первого приближения
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.SpeedyNext(System.Int32)">
            <summary>
            Метод наискорейшего спуска без начального присвоения (используется вектор х, изначально нулевой либо изменёный в другом методе)
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Minimize_coef(System.Int32,System.Int32)">
            <summary>
            Покоординатная минимизация коэффициентов
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.GaussSpeedy(System.Int32)">
            <summary>
            Метод Гаусса с последующим улучшением решения методом наискорейшего спуска
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.GaussSpeedyMinimize(System.Int32)">
            <summary>
            Метод Гаусса + метод наискорейшего спуска + метод поокрдинатной минимизации
            </summary>
            <param name="t"></param>
        </member>
        <member name="T:МатКлассы.SLAU.Method">
            <summary>
            Перечисление методов решения системы
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.Show">
            <summary>
            Вывести систему на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.ShowRational">
            <summary>
            Вывести систему c рациональными числами на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.ShowErrors">
            <summary>
            Вывести систему, её решение и невязки от разных методов
            </summary>
        </member>
        <member name="F:МатКлассы.SLAU.UltraCount">
            <summary>
            Число, которое показывает, какая часть системы уже была решена ультра-гибридом
            </summary>
        </member>
        <member name="M:МатКлассы.SLAU.UltraHybridLast(System.Int32,МатКлассы.SequenceFuncKind)">
            <summary>
            Ультра-гибридный метод суперского решения по последней координате
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:МатКлассы.SLAU.Correction(System.Double,System.Int32)">
            <summary>
            Уточнение решения СЛАУ по Уилкинсону
            </summary>
            <param name="eps">Норма невязки, до которой нужно уточнять</param>
            <param name="maxcount">Максимальное число итераций</param>
        </member>
        <member name="T:МатКлассы.SqMatrix">
            <summary>
            Квадратные матрицы
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor">
            <summary>
            Матрица (0)
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.Int32)">
            <summary>
            Нулевая квадратная матрица
            </summary>
            <param name="n">Размерность матрицы</param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.IO.StreamReader)">
            <summary>
            Считать матрицу из файла
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(МатКлассы.SqMatrix)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.Int32[0:,0:])">
            <summary>
            Создание матрицы по двумерному массиву
            </summary>
            <param name="S"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Создание матрицы по двумерному массиву
            </summary>
            <param name="S"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(МатКлассы.SqMatrix,System.Int32)">
            <summary>
            Создать матрицу как угловую подматрицу размерности k
            </summary>
            <param name="A"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.Double[0:,0:],System.Int32)">
            <summary>
            Создать матрицу как угловую подматрицу размерности k
            </summary>
            <param name="A"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(МатКлассы.Matrix)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.#ctor(System.Double[])">
            <summary>
            Создание матрицы по одномерному массиву
            </summary>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.SqMatrix.I(System.Int32)">
            <summary>
            Единичная матрица
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.Diagonal">
            <summary>
            Диагональная ли матрица?
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.IsSymmetric">
            <summary>
            Является ли матрица симметрической
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.IsPositCertain">
            <summary>
            Является ли матрица положительно определённой
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.IsTreeDiag">
            <summary>
            Является ли матрица тридиагональной
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.E(System.Int32)">
            <summary>
            Единичная матрица
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.SqMatrix.Det">
            <summary>
            Определитель матрицы
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.Minor(System.Int32,System.Int32)">
            <summary>
            Минор элемента матрицы (точнее, алгебраическое дополнение)
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.SqMatrix.Track">
            <summary>
            Трек матрицы
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.SqMatrix.CharactPol">
            <summary>
            Характеристический многочлен заданной матрицы
            </summary>
        </member>
        <member name="P:МатКлассы.SqMatrix.Reverse">
            <summary>
            Обратная матрица
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.Invert">
            <summary>
            Обратная матрица по Гауссу
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.ReverseCorrect(МатКлассы.SqMatrix,МатКлассы.SqMatrix,System.Double,System.Int32,System.Boolean)">
            <summary>
            Уточнение обратной матрицы
            </summary>
            <param name="A">Исходная матрица</param>
            <param name="Reverse">Обратная марица</param>
            <param name="eps">Точность</param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.SqMatrix.Invertion">
            <summary>
            Обратная матрица через MathNet
            </summary>
        </member>
        <member name="M:МатКлассы.SqMatrix.SubMatrix(System.Int32[])">
            <summary>
            Квадратная подматрица, порождённая пересечением таких строк и столбцов
            </summary>
            <param name="m"></param>
            <returns></returns>
            <remarks>Нумерация строк должна начинаться с единицы</remarks>
        </member>
        <member name="M:МатКлассы.SqMatrix.ColumnSwap(System.Int32,МатКлассы.Vectors)">
            <summary>
            Замена столбца матрицы на указанный вектор (для метода Крамера)
            </summary>
            <param name="ColumnNumber">Номер стоблца, начиная с 1</param>
            <param name="NewColumn">Сам вектор (если вектор)</param>
            <remarks>Если вектор короткий, заменится лишь часть колонны, а если длинный, будет исключение</remarks>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.ConvertToSimilar(МатКлассы.SqMatrix,System.Boolean)">
            <summary>
            Подобная матрица, если задана ортогональная матрица преобразования
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.ToDoubleMas(МатКлассы.SqMatrix)">
            <summary>
            Перевод матрицы в одномерный массив
            </summary>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.SubMatrix(System.Int32)">
            <summary>
            Подматрица размерности len
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SqMatrix.Solve(МатКлассы.Vectors)">
            <summary>
            Вектор x решения системы Ax=b
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SumsAndLimits">
            <summary>
            Класс методов суммирования
            </summary>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Int32,System.Int32,System.Func{System.Int32,МатКлассы.Number.Complex})">
            <summary>
            Сумма частичного ряда
            </summary>
            <param name="n0">Начальный номер члена ряда</param>
            <param name="nmax">Конечный номер члена ряда</param>
            <param name="f">Функция, сопоставляющая член ряда по номеру</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Int32,System.Func{System.Int32,МатКлассы.Number.Complex},System.Double,System.Int32,System.Int32)">
            <summary>
            Сумма бесконечного ряда
            </summary>
            <param name="n0">Начальный номер члена ряда</param>
            <param name="f">Функция, сопоставляющая член ряда номеру</param>
            <param name="eps">Точность</param>
            <param name="ndo">Минимальное количество членов, которые должны быть суммированы</param>
            <param name="ndomax">Максимальное число суммируемых членов</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Func{System.Int32,МатКлассы.Number.Complex},System.Double,System.Int32)">
            <summary>
            Сумма ряда от -inf до inf
            </summary>
            <param name="f">Функция, сопоставляющая член ряда номеру</param>
            <param name="eps">Точность</param>
            <param name="ndo">Минимальное количество членов, которые должны быть суммированы в одну сторону</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Int32,System.Int32,System.Func{System.Int32,МатКлассы.CVectors})">
            <summary>
            Сумма частичного ряда
            </summary>
            <param name="n0">Начальный номер члена ряда</param>
            <param name="nmax">Конечный номер члена ряда</param>
            <param name="f">Функция, сопоставляющая член ряда по номеру</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Int32,System.Func{System.Int32,МатКлассы.CVectors},System.Double,System.Int32,System.Int32)">
            <summary>
            Сумма бесконечного ряда
            </summary>
            <param name="n0">Начальный номер члена ряда</param>
            <param name="f">Функция, сопоставляющая член ряда номеру</param>
            <param name="eps">Точность</param>
            <param name="ndo">Минимальное количество членов, которые должны быть суммированы</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.Sum(System.Func{System.Int32,МатКлассы.CVectors},System.Double,System.Int32)">
            <summary>
            Сумма ряда от -inf до inf
            </summary>
            <param name="f">Функция, сопоставляющая член ряда номеру</param>
            <param name="eps">Точность</param>
            <param name="ndo">Минимальное количество членов, которые должны быть суммированы в одну сторону</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.LimitCircle(System.Func{МатКлассы.Number.Complex,МатКлассы.CSqMatrix},МатКлассы.Number.Complex,System.Double,System.Int32,System.Int32)">
            <summary>
            Вычисление предела комплексной матричной функции в точке через окружности
            </summary>
            <param name="f">Функция</param>
            <param name="point">Точка, где нужно найти предел</param>
            <param name="begeps">Начальный радиус</param>
            <param name="count">Число усредняющихся точек</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SumsAndLimits.LimitRandom(System.Func{МатКлассы.Number.Complex,МатКлассы.CSqMatrix},МатКлассы.Number.Complex,System.Double,System.Int32,System.Boolean)">
            <summary>
            Вычисление предела комплексной матричной функции в точке при случайном разбросе
            </summary>
            <param name="f">Функция</param>
            <param name="point">Точка, где нужно найти предел</param>
            <param name="radius">Радиус приближения</param>
            <param name="count">Число усредняющихся точек</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.UnderUncertainty">
            <summary>
            Критерии принятия решений в условиях неопределённости
            </summary>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.AverageGain(МатКлассы.Matrix,МатКлассы.Vectors@,МатКлассы.Vectors)">
            <summary>
            Критерий среднего выйгрыша
            </summary>
            <param name="S">Матрица решений</param>
            <param name="q">Вектор вероятностей</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.MiniMax(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий минимакса
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.MaxiMax(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий максимакса
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Laplas(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий Лапласа
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Vald(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий Вальда (максимин)
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Savage(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий Сэвиджа
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Hurwitz(МатКлассы.Matrix,МатКлассы.Vectors@,System.Double)">
            <summary>
            Критерий Гурвица
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
            <param name="a">Коэффициент оптимизма</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.HodgeLeman(МатКлассы.Matrix,МатКлассы.Vectors@,System.Double,МатКлассы.Vectors)">
            <summary>
            Критерий Ходжа-Лемана
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
            <param name="a">Коэффициент метода (вес)</param>
            <param name="q">Вектор вероятностей</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Germeier(МатКлассы.Matrix,МатКлассы.Vectors@,МатКлассы.Vectors)">
            <summary>
            Критерий Гермейера
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="M:МатКлассы.UnderUncertainty.Powers(МатКлассы.Matrix,МатКлассы.Vectors@)">
            <summary>
            Критерий произведений
            </summary>
            <param name="S">Матрица решений</param>
            <param name="v">Дополнительный столбец</param>
        </member>
        <member name="T:МатКлассы.Vectors">
            <summary>
            Обычные векторы
            </summary>
        </member>
        <member name="F:МатКлассы.Vectors.vector">
            <summary>
            Массив, с которым отождествляется вектор
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Deg">
            <summary>
            Размерность вектора
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.DoubleMas">
            <summary>
            Массив, соответствующий вектору
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.EuqlidNorm">
            <summary>
            Евклидова норма вектора
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Normalizing">
            <summary>
            Возвращает нормированный вектор
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Item(System.Int32)">
            <summary>
            Использование вектора как массива
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Vectors.ArithmeticAv">
            <summary>
            Среднее арифметическое значений в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Center">
            <summary>
            Среднее арифметическое
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Range">
            <summary>
            Размах значений в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Sum">
            <summary>
            Сумма элементов вектора
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Average">
            <summary>
            Среднее отклонение значений в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.RelAc">
            <summary>
            Относительная погрешность значений в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.RelAcVec">
            <summary>
            Вектор отклонений от среднего значения в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.RelAcSqr">
            <summary>
            Вектор квадратов отклонений от среднего значения в векторе
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Max">
            <summary>
            Максимальное значение
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Min">
            <summary>
            Минимальное значение
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.Sort">
            <summary>
            Отсортированный вектор
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.AbsVector">
            <summary>
            Вектор модулей
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.MaxAbs">
            <summary>
            Максимальный элемент по модулю
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.MinAbs">
            <summary>
            Минимальный элемент по модулю
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.ToAver">
            <summary>
            Усреднённый вектор
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.ToAverDel">
            <summary>
            Вектор, делённый на своё среднее
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.LastElement">
            <summary>
            Последний элемент вектора
            </summary>
        </member>
        <member name="P:МатКлассы.Vectors.dup">
            <summary>
            Дубликат вектора
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor">
            <summary>
            Вектор (0)
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.Int32)">
            <summary>
            Нулевой вектор
            </summary>
            <param name="n">Размерность вектора</param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.Int32,System.Double)">
            <summary>
            Вектор, заполненный одинаковыми числами
            </summary>
            <param name="n">Размерность вектора</param>
            <param name="c">Конпонент вектора</param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.IO.StreamReader)">
            <summary>
            Считать вектор из файла
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(МатКлассы.Vectors)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="V"></param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.Double[])">
            <summary>
            Задать вектор перечислением координат или массивом
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.Int32[])">
            <summary>
            Задать вектор массивом целых чисел
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(МатКлассы.Matrix)">
            <summary>
            Задать вектор по вектору-столбцу
            </summary>
            <param name="M"></param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(МатКлассы.Vectors,System.Int32,System.Int32)">
            <summary>
            Вектор как кусок кругого вектора
            </summary>
            <param name="v">Образец</param>
            <param name="a">Коэффициент начала из образца</param>
            <param name="b">Коэффициент конца из образца</param>
        </member>
        <member name="M:МатКлассы.Vectors.#ctor(System.String)">
            <summary>
            Метод, обратный ToString
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:МатКлассы.Vectors.IsIn(System.Double,System.Double)">
            <summary>
            Находятся ли все значения вектора в указанно промежутке
            </summary>
            <param name="beg"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Av(System.Int32)">
            <summary>
            Отклонение элемента от среднего значения
            </summary>
            <param name="i">Номер элемента</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.TrueValShow">
            <summary>
            Вывести истинное значение величины на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.TrueValShowFull">
            <summary>
            Показать всю информацию о векторе как о реализации величины
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.ToDoubleMas(МатКлассы.Vectors)">
            <summary>
            Перевести вектор в массив чисел
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Contain(System.Double)">
            <summary>
            Содержится ли указанное число в векторе
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Merge(МатКлассы.Vectors[])">
            <summary>
            Слияние нескольких векторов со состыковкой крайних вершин (конец предыдущего вектора должен совпадать с началом последующего)
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.IsSimpleCycle(МатКлассы.Vectors)">
            <summary>
            Описывает ли вектор простой цикл (первая и последняя вершины должны повторяться, но больше в нём не должно содержаться повторяющихся вершин)
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.CreateMatrix">
            <summary>
            Задать коэффициенты через консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.PrintMatrix">
            <summary>
            Вывести вектор на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.Nulle">
            <summary>
            Нулевой ли вектор?
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ToString">
            <summary>
            Перевод вектора в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ToStringPlusOne">
            <summary>
            Перевод вектора (все координаты которого увеличены на 1) в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ToRationalString">
            <summary>
            Перевод вектора в строку с рациональными числами
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ToRationalStringTab">
            <summary>
            Перевод вектора в строку с рациональными числами с табуляцией
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Show">
            <summary>
            Вывести вектор на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.ShowPlusOne">
            <summary>
            Вывести вектор (все координаты которого увеличены на 1) на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.ShowRational">
            <summary>
            Вывести вектор в рациональном виде на консоль
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.ShowRationalTab">
            <summary>
            Вывести вектор в рациональном виде на консоль с табуляцией
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.Show(МатКлассы.Vectors[])">
            <summary>
            Вывести массив векторов на консоль
            </summary>
            <param name="lines"></param>
        </member>
        <member name="M:МатКлассы.Vectors.Show(МатКлассы.Vectors[],System.IO.StreamWriter)">
            <summary>
            Вывести массив векторов в файл
            </summary>
            <param name="lines"></param>
            <param name="sf"></param>
        </member>
        <member name="M:МатКлассы.Vectors.ShowInfo(МатКлассы.Vectors,System.IO.StreamWriter)">
            <summary>
            Вывести информацию об векторе в файл
            </summary>
            <param name="v"></param>
            <param name="fs"></param>
        </member>
        <member name="M:МатКлассы.Vectors.ShowRational(МатКлассы.Vectors[])">
            <summary>
            Вывести массив векторов c рациональными коэффициентами на консоль
            </summary>
            <param name="lines"></param>
        </member>
        <member name="M:МатКлассы.Vectors.SimpleSimplex(МатКлассы.Vectors@,System.IO.StreamReader)">
            <summary>
            Нахождение максимума функционала методами симплекс-таблицы, считанной из файла
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="fs">Файл с матрицей (симплекс-таблицей) размера (x.Lenth+1)X(xbase.Lenth+1) (образец)</param>
            <returns>Наибольшее значение функционала, который задан последней строкой таблицы</returns>
            <remarks>Не предусматривается возможность вырожденного решения</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.SimpleSimplex(МатКлассы.Vectors@,МатКлассы.Vectors[]@)">
            <summary>
            Нахождение максимума функционала методами симплекс таблицы, заданной массивом векторов
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="lines">Симплекс-таблица, заданная массивом векторов</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ExistColumn(МатКлассы.Vectors[])">
            <summary>
            Проверяет симплекс-таблицу на наличие столбца с положительным элементом, где коэффициент при линейной форме отрицателен
            </summary>
            <param name="l"></param>
            <returns>Номер найденного столбца или 0, если таковой отсутствует</returns>
            <remarks>Выбирается стобец с наибольшей по модулю отрицательной частью в конце</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.FindPosElem(МатКлассы.Vectors[],System.Int32)">
            <summary>
            Найти позицию элемента, который годится под центр в симплекс-таблице
            </summary>
            <param name="l">Симплекс-таблица</param>
            <param name="k">Номер столбца, где этот элемент ищется</param>
            <returns>Номер строки, где этот элемент находится</returns>
        </member>
        <member name="M:МатКлассы.Vectors.Transform(МатКлассы.Vectors[]@,System.Int32,System.Int32,МатКлассы.Vectors@)">
            <summary>
            Преобразует симплекс-таблицу по годному элементу в центре
            </summary>
            <param name="l">Симплекс-таблица</param>
            <param name="k">Номер строки, где находится элемент</param>
            <param name="m">Номер столбца, где находится элемент</param>
        </member>
        <member name="M:МатКлассы.Vectors.ExistInfinity(МатКлассы.Vectors[])">
            <summary>
            Проверяет симплекс-таблицу на наличие столбца, характеризующего отсутствие решения
            </summary>
            <param name="l"></param>
            <returns>Номер такого столбца и 0 при его отсутствии</returns>
        </member>
        <member name="M:МатКлассы.Vectors.SimplexInteger(МатКлассы.Vectors@,System.IO.StreamReader)">
            <summary>
            (Старый) Поиск целочисленного решения задачи линейного программирования, заданной симплекс-таблицей
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="fs">Файл с матрицей (симплекс-таблицей) размера (x.Lenth+1)X(xbase.Lenth+1)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.IsIntDesigion(МатКлассы.Vectors[])">
            <summary>
            Проверка на то, содержится ли в симплекс-таблице целочисленное решение
            </summary>
            <param name="l"></param>
            <returns>True, если содержится</returns>
        </member>
        <member name="M:МатКлассы.Vectors.NumberOfNotIntDes(МатКлассы.Vectors[])">
            <summary>
            Возвращает номер оптимальной строки, где решение не является целочисленными
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ImpossibleFoundIntDesigion(МатКлассы.Vectors[])">
            <summary>
            Проверка невозможности нахождения целочисленного решения
            </summary>
            <param name="l"></param>
            <returns>True, если целочисленное решение найти невозможно</returns>
            <remarks>Целочисленного решения не существует, если в какой-то столбце имеется дробный свободный коэффициент, а все остальные коэффициенты - целые</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.GetSolutionVec(МатКлассы.Vectors[])">
            <summary>
            Получить вектор решения по симплекс-таблице
            </summary>
            <param name="lines"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Show(System.IO.StreamWriter)">
            <summary>
            Вывести вектор в файл
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.ShowRational(МатКлассы.Vectors[],System.IO.StreamWriter)">
            <summary>
            Вывести массив векторов c рациональными коэффициентами в файл
            </summary>
            <param name="lines"></param>
            <param name="sf"></param>
        </member>
        <member name="M:МатКлассы.Vectors.SimpleSimplex(МатКлассы.Vectors@,System.IO.StreamReader,System.IO.StreamWriter)">
            <summary>
            Нахождение максимума функционала методами симплекс-таблицы, считанной из файла, с выводом в файл
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="fs">Файл с матрицей (симплекс-таблицей) размера (x.Lenth+1)X(xbase.Lenth+1) (образец)</param>
            <param name="sf"></param>
            <returns>Наибольшее значение функционала, который задан последней строкой таблицы</returns>
            <remarks>Не предусматривается возможность вырожденного решения</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.SimpleSimplex(МатКлассы.Vectors@,МатКлассы.Vectors[]@,System.IO.StreamWriter)">
            <summary>
            Нахождение максимума функционала методами симплекс таблицы, заданной массивом векторов
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="lines">Симплекс-таблица, заданная массивом векторов</param>
            <param name="sf"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.SimplexInteger(МатКлассы.Vectors@,System.IO.StreamReader,System.IO.StreamWriter)">
            <summary>
            Поиск целочисленного решения задачи линейного программирования, заданной симплекс-таблицей
            </summary>
            <param name="result">Вектор вида (0,0,1,0,1), показывающий, какие переменные являются базисными</param>
            <param name="fs">Файл с матрицей (симплекс-таблицей) размера (x.Lenth+1)X(xbase.Lenth+1)</param>
            <param name="sf"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ExistColumnDual(МатКлассы.Vectors[])">
            <summary>
            Проверяет симплекс-таблицу на наличие столбца (то есть строки, так как решается двойственная задача) с положительным элементом, где коэффициент при линейной форме отрицателен
            </summary>
            <param name="l"></param>
            <returns>Номер найденного столбца или 0, если таковой отсутствует</returns>
            <remarks>Выбирается стобец с наибольшей по модулю отрицательной частью в конце</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.FindPosElemDual(МатКлассы.Vectors[],System.Int32)">
            <summary>
            Найти позицию элемента, который годится под центр в симплекс-таблице (при решении двойственной задачи)
            </summary>
            <param name="l">Симплекс-таблица</param>
            <param name="k">Номер столбца, где этот элемент ищется</param>
            <returns>Номер строки, где этот элемент находится</returns>
        </member>
        <member name="M:МатКлассы.Vectors.NotExistColumn(МатКлассы.Vectors[])">
            <summary>
            Проверяет симплекс-таблицу на отсутствие столбца с положительным элементом, где коэффициент при линейной форме отрицателен
            </summary>
            <param name="l"></param>
            <returns>Номер найденного столбца или 0, если таковой отсутствует</returns>
            <remarks>Выбирается стобец с наибольшей по модулю отрицательной частью в конце</remarks>
        </member>
        <member name="M:МатКлассы.Vectors.LinesToMatrix(МатКлассы.Vectors[])">
            <summary>
            Перевод массива строк в матрицу
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.MatrixToLines(МатКлассы.Matrix)">
            <summary>
            Перевод матрицы в массив строк
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ExistIntersection(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Содержат ли векторы общий элемент
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.FastAdd(МатКлассы.Vectors)">
            <summary>
            Быстрое прибавление вектора
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:МатКлассы.Vectors.op_Equality(МатКлассы.Vectors,System.Double)">
            <summary>
            Сравнение всех элементов с числом
            </summary>
            <param name="a"></param>
            <param name="Ch"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Distance(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Евклидово расстояние между векторами
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Mix(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Смешение векторов abcd и xyz в вектор axbyczd
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.UnionWith(МатКлассы.Vectors)">
            <summary>
            Объединение с другим вектором, вдобавок сортировка
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Union(МатКлассы.Vectors[])">
            <summary>
            Простое объединение массива векторов (без сортировки!)
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Union2(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Прострое объединение двух векторов
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Repeat(МатКлассы.Vectors,System.Int32)">
            <summary>
            Повторить указанный вектор указанно число раз
            </summary>
            <param name="v"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.CompMult(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Покомпонентное произведение векторов
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(System.Int32,System.Double,System.Double)">
            <summary>
            Создать вектор указанной размерности со случайными числами из указанного диапазона
            </summary>
            <param name="dim"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(МатКлассы.Matrix,System.Boolean)">
            <summary>
            Перевести матрицу в вектор
            </summary>
            <param name="A"></param>
            <param name="col">Если true, элементы вектора собираются в первую очередь слева-направо, иначе сверху-вниз</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(МатКлассы.Vectors,System.Double)">
            <summary>
            Создать случайный вектор из delta-окрестности указанного вектора
            </summary>
            <param name="center"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(МатКлассы.Vectors,МатКлассы.Vectors)">
            <summary>
            Создать случайный вектор между двумя заданными векторами
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(System.Double[])">
            <summary>
            Создать вектор по массиву чисел
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Create(System.Double,System.Int32)">
            <summary>
            Вектор, заполненный одинаковыми числами
            </summary>
            <param name="number"></param>
            <param name="repeatcount"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Random(System.Int32,System.Double,System.Double)">
            <summary>
            Случайный вектор указанной размерности
            </summary>
            <param name="degree"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Vectors.DistNorm">
            <summary>
            Cумма квадратов элементов вектора
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.VectorsToFile(МатКлассы.Vectors[],System.String)">
            <summary>
            Записать массив векторов в файл
            </summary>
            <param name="mas"></param>
            <param name="filename"></param>
        </member>
        <member name="M:МатКлассы.Vectors.VectorsFromFile(System.String)">
            <summary>
            Получить массив векторов из файла
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.Normalize(System.Double,System.Double)">
            <summary>
            Нормализовать значения в векторе к отрезку
            </summary>
            <param name="c"></param>
            <param name="d"></param>
        </member>
        <member name="P:МатКлассы.Vectors.Norming">
            <summary>
            Исходный вектор, делённый на своё максимальное значение, чтобы принимать значения из [0,1] (предполагается, что в нём нет отрицательных элементов)
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.SubVector(System.Int32)">
            <summary>
            Подвектор из первых len элементов
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Vectors.MinDist">
            <summary>
            Минимальная разница между соседними компонентами в векторе
            </summary>
        </member>
        <member name="M:МатКлассы.Vectors.BinaryApproxSearch(System.Double)">
            <summary>
            Ищет наиболее близкий к d элемент отсортированного массива
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.CreateFast(System.Double[])">
            <summary>
            Быстро создаёт вектор за счёт копирования ссылки на массив, а не дублирования массива
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.VectorFromFile(System.String)">
            <summary>
            Прочитать вектор из файла
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Vectors.ToFile(System.String,System.Boolean)">
            <summary>
            Записать вектор в файл
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:МатКлассы.Vectors.MoveTo(МатКлассы.Vectors)">
            <summary>
            Перенести вектор без создания новых векторов
            </summary>
            <param name="t"></param>
        </member>
        <member name="T:МатКлассы.SetOfVectors">
            <summary>
            Множество векторов
            </summary>
        </member>
        <member name="P:МатКлассы.SetOfVectors.M">
            <summary>
            Мощность множества
            </summary>
        </member>
        <member name="M:МатКлассы.SetOfVectors.Dist(МатКлассы.Vectors)">
            <summary>
            Расстояние до множества от вектора
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Wavelet">
            <summary>
            Класс с вейвлетным преобразованием
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.countNodes">
            <summary>
            Число узлов для интегрирования
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Cpsi">
            <summary>
            Коллекция нормирующих множителей
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.w">
            <summary>
            Частота (нужна только для вейвлета Морле)
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Mother">
            <summary>
            Материнский вейвлет/анализирующий вейвлет
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.FMother">
            <summary>
            Фурье-образ материнского вейвлета
            </summary>
        </member>
        <member name="P:МатКлассы.Wavelet.Type">
            <summary>
            Тип исходного вейвлета
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.eps">
            <summary>
            Допустимая погрешность
            </summary>
        </member>
        <member name="T:МатКлассы.Wavelet.Wavelets">
            <summary>
            Перечисление доступных вейвлетов
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.WAVE">
            <summary>
            Гауссов вейвлет первого порядка
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.MHAT">
            <summary>
            Мексиканская шляпа
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.DOG">
            <summary>
            "difference of gaussians"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:МатКлассы.Wavelet.Wavelets.LP" -->
        <member name="F:МатКлассы.Wavelet.Wavelets.HAAR">
            <summary>
            Хаар-вейвлет
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.FHAT">
            <summary>
            Французская шляпа
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.Morlet">
            <summary>
            Вейвлет Морле
            </summary>
        </member>
        <member name="F:МатКлассы.Wavelet.Wavelets.Gabor">
            <summary>
            Вейвлет Габора
            </summary>
        </member>
        <member name="M:МатКлассы.Wavelet.#ctor(МатКлассы.Wavelet.Wavelets,System.Double)">
            <summary>
            Создание вейвлета по масштабному множителю с указанием вейвлета из перечисления
            </summary>
            <param name="W"></param>
            <param name="ww"></param>
            <param name="k"></param>
        </member>
        <member name="M:МатКлассы.Wavelet.Create(МатКлассы.Wavelet.Wavelets,System.Double)">
            <summary>
            Создать вейвлет
            </summary>
            <param name="W"></param>
            <param name="k"></param>
            <param name="ww"></param>
            <returns></returns>
        </member>
        <member name="F:МатКлассы.Wavelet.ResultMemoized">
            <summary>
            Функция, получившаяся при последнем анализе 
            </summary>
        </member>
        <member name="M:МатКлассы.Wavelet.GetAnalys(System.Func{System.Double,System.Double})">
            <summary>
            Вейвлет-образ указанной функции
            </summary>
            <param name="f"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Wavelet.GetAnalys(МатКлассы.Point[],System.Double,System.Double,System.Double)">
            <summary>
            Вейвлет-преобразование от массива точек по формулам Котеса
            </summary>
            <param name="farr">Временной ряд</param>
            <param name="tmin">Минимум по времени</param>
            <param name="tmax">Максимум по времени</param>
            <param name="epsForWaveletValues">Ограничение на интегрирование</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Wavelet.GetMinMaxIndexies(МатКлассы.Point[],System.Double,System.Double)">
            <summary>
            Возвратить индексы элементов массива точек, в которых компонента x наиболее близка к указанным значениям
            </summary>
            <param name="farr"></param>
            <param name="tmin"></param>
            <param name="tmax"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Wavelet.GetAnalys(System.Double,System.Double,System.Int32,System.Double,System.Double,System.String,System.String,System.Int32,System.Double)">
            <summary>
            Вейвлет-преобразование от замера, записанного в файл
            </summary>
            <param name="begin"></param>
            <param name="step"></param>
            <param name="count"></param>
            <param name="filename"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Wavelet.GetSyntesis(System.Func{System.Double,System.Double,МатКлассы.Number.Complex})">
            <summary>
            Обратное вейвлет-преобразование указанной функции
            </summary>
            <param name="F"></param>
            <returns></returns>
            <remarks>Сам несобственный интеграл считается параллельно, так что рисовать эту функцию лучше последовательно, что ввиду мемоизации будет раз в 6 быстрее, чем рисовать параллельно и считать последовательно</remarks>
        </member>
        <member name="T:МатКлассы.Waves">
            <summary>
            Класс, обеспечивающий исследование колебаний
            </summary>
        </member>
        <member name="T:МатКлассы.Waves.Normal2D">
            <summary>
            Нормаль
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.Normal2D.n">
            <summary>
            Вектор нормали
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.Normal2D.Position">
            <summary>
            Позиция приложения
            </summary>
        </member>
        <member name="M:МатКлассы.Waves.Normal2D.#ctor(МатКлассы.Point,МатКлассы.Point,System.Double)">
            <summary>
            Создание вектора нормали к точке на окружности
            </summary>
            <param name="center">Центр окружности</param>
            <param name="position">Декартовы координаты точки на окружности</param>
            <param name="coefficent">Коэффициент умножения нормали</param>
        </member>
        <member name="M:МатКлассы.Waves.Normal2D.#ctor(System.Double,МатКлассы.Point,МатКлассы.Point)">
            <summary>
            Конструктор для копирования с дополнительным умножением
            </summary>
            <param name="coef"></param>
            <param name="normal"></param>
            <param name="position"></param>
        </member>
        <member name="M:МатКлассы.Waves.Normal2D.NormalsToPoins(МатКлассы.Waves.Normal2D[])">
            <summary>
            Возвращает массив нормалей как массив точек
            </summary>
            <param name="mas"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Normal2D.op_Multiply(МатКлассы.Waves.Normal2D,System.Double)">
            <summary>
            Умножить нормаль на число
            </summary>
            <param name="s"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Waves.Normal2D.Corner">
            <summary>
            Угол относительно оси Х и точки, из которой исходит нормаль
            </summary>
        </member>
        <member name="T:МатКлассы.Waves.Circle">
            <summary>
            Окружность
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.Circle.center">
            <summary>
            Центр окружности
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.Circle.radius">
            <summary>
            Радиус окружности
            </summary>
        </member>
        <member name="M:МатКлассы.Waves.Circle.#ctor(МатКлассы.Point,System.Double)">
            <summary>
            Создать окружность по центру и радиусу
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.#ctor(МатКлассы.Waves.Circle)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Окружностб по координатам центра и радиусу
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="radius"></param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.GetNormal(System.Double,System.Double)">
            <summary>
            Возврат нормали в точке по аргументу
            </summary>
            <param name="arg"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Circle.ContainPoint(МатКлассы.Point,System.Double)">
            <summary>
            Создержит ли круг точку (взято с запасом)
            </summary>
            <param name="p"></param>
            <param name="RadiusCoef">Коэффициент определяющий, сколько радиусов от центра круга считаются собственностью окружности</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Circle.GetNormalsOnCircle(System.Double[],System.Double[])">
            <summary>
            Возвращает массив точек на окружности
            </summary>
            <param name="args">Углы точек относительно центра окружности и оси X</param>
            <param name="weights">Веса точек (по умолчанию единичные)</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Circle.GetNormalsOnCircle(System.Int32,System.Double[])">
            <summary>
            Возвращает массив равномерно рассположенных по окружности нормалей
            </summary>
            <param name="count"></param>
            <param name="weights"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Circle.FieldToFileParallel(System.String,System.Func{System.Double,System.Double,System.ValueTuple{МатКлассы.Number.Complex,МатКлассы.Number.Complex}},System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32,System.IProgress{System.Int32},System.Threading.CancellationToken,System.Func{МатКлассы.Point,System.Boolean},System.String)">
            <summary>
            Записать поле (массивы аргументов x,y) и массивы значений Re ur, Im ur, Abs ur, Re uz, Im uz, Abs uz в файл (чтобы потом нарисовать графики). Реализация параллельная
            </summary>
            <param name="filename">Имя файла</param>
            <param name="title">То, что должно быть позже написано над графиками</param>
            <param name="F">Функция (x,y,normal) -> (ur, uz)</param>
            <param name="x0">Начало отрезка по х</param>
            <param name="X">Конец отрезка по х</param>
            <param name="xcount">Число точек по х</param>
            <param name="y0">Начало отрезка по у</param>
            <param name="Y">Конец отрезка по у</param>
            <param name="ycount">Число точек по у</param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.FieldToFileOLD(System.String,System.String,System.Func{System.Double,System.Double,System.ValueTuple{System.Double,System.Double}},System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32,System.IProgress{System.Int32},System.Threading.CancellationToken,System.Func{МатКлассы.Point,System.Boolean},System.String,System.Boolean)">
            <summary>
            Записать поле (массивы аргументов x,y) и массивы значенийur, ur, uz в файл (чтобы потом нарисовать графики)
            </summary>
            <param name="filename">Имя файла</param>
            <param name="title">То, что должно быть позже написано над графиками</param>
            <param name="F">Функция (x,y,normal) -> (ur, uz)</param>
            <param name="x0">Начало отрезка по х</param>
            <param name="X">Конец отрезка по х</param>
            <param name="xcount">Число точек по х</param>
            <param name="y0">Начало отрезка по у</param>
            <param name="Y">Конец отрезка по у</param>
            <param name="ycount">Число точек по у</param>
            <param name="k">Массив для отслеживания прогресса</param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.FieldToFile(System.String,System.String,System.Func{System.Double,System.Double,System.ValueTuple{System.Double,System.Double}},System.Double[],System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Threading.CancellationToken,System.Func{МатКлассы.Point,System.Boolean},System.String,System.Boolean)">
            <summary>
            Записать поле (массивы аргументов x,y) и массивы значенийur, ur, uz в файл (чтобы потом нарисовать графики). Рабочая версия для последовательного вызова
            </summary>
            <param name="filename">Имя файла</param>
            <param name="path"></param>
            <param name="title">То, что должно быть позже написано над графиками</param>
            <param name="parallel"></param>
            <param name="F">Функция (x,y,normal) -> (ur, uz)</param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="urt"></param>
            <param name="uzt"></param>
            <param name="token"></param>
            <param name="Filter"></param>
            <param name="Y">Конец отрезка по у</param>
            <param name="k">Массив для отслеживания прогресса</param>
        </member>
        <member name="M:МатКлассы.Waves.Circle.FieldToFile(System.String,System.Func{System.Double,System.Double,System.ValueTuple{System.Double,System.Double}},System.Double[],System.Double[],System.Threading.CancellationToken,System.Func{МатКлассы.Point,System.Boolean},System.String)">
            <summary>
            Записать поле (массивы аргументов x,y) и массивы значений ur, uz в файл последовательно (не для рисования графиков). Рабочая версия для параллельного вызова
            </summary>
            <param name="filename">Имя файла</param>
            <param name="title">То, что должно быть позже написано над графиками</param>
            <param name="F">Функция (x,y,normal) -> (ur, uz)</param>
            <param name="x0">Начало отрезка по х</param>
            <param name="X">Конец отрезка по х</param>
            <param name="xcount">Число точек по х</param>
            <param name="y0">Начало отрезка по у</param>
            <param name="Y">Конец отрезка по у</param>
            <param name="ycount">Число точек по у</param>
            <param name="k">Массив для отслеживания прогресса</param>
        </member>
        <member name="T:МатКлассы.Waves.DCircle">
            <summary>
            Окружность с вырезом, представимым как круг с центром на большой окружности
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.DCircle.circle1">
            <summary>
            Окружности
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.DCircle.circle2">
            <summary>
            Окружности
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.DCircle.arg">
            <summary>
            Аргумент, определяющий положение центра меньшей окружности
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.DCircle.alp1">
            <summary>
            Центральные половинные углы окружностей в радианах
            </summary>
        </member>
        <member name="F:МатКлассы.Waves.DCircle.alp2">
            <summary>
            Центральные половинные углы окружностей в радианах
            </summary>
        </member>
        <member name="P:МатКлассы.Waves.DCircle.Radius">
            <summary>
            Радиус большего круга
            </summary>
        </member>
        <member name="P:МатКлассы.Waves.DCircle.Center">
            <summary>
            Центр полумесяца как центр большего круга
            </summary>
        </member>
        <member name="P:МатКлассы.Waves.DCircle.BigCircle">
            <summary>
            Копия большего круга
            </summary>
        </member>
        <member name="P:МатКлассы.Waves.DCircle.DiamsAndArg">
            <summary>
            Возвращает пару диаметров и аргумент центра
            </summary>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.#ctor(МатКлассы.Point,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Окружность с вырезом
            </summary>
            <param name="center">Центр большей окружности</param>
            <param name="diam1">Диамерт большей окружности</param>
            <param name="diam2">Диаметр меньшей окружности</param>
            <param name="arg">Угол в радианах, определяющий положение центра меньшей окружности</param>
            <param name="FirstNomnalsCount"></param>
            <param name="SecondNomnalsCount"></param>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.#ctor(МатКлассы.Waves.DCircle)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="dc"></param>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.ContainPoint(МатКлассы.Point,System.Double)">
            <summary>
            Содержит ли окружность с вырезом точку в своей внутренности (взято с запасом)
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.ContainPointCurrent(МатКлассы.Point)">
            <summary>
            Содержит ли окружность с вырезом точку
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.GetNormal(МатКлассы.Point,System.Double,System.Double)">
            <summary>
            Возвращает нормаль для точки на плоскости
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.GetArraysForDraw(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Возвращает массив точек и массив нормалей в этих точках
            </summary>
            <param name="FirstNomnalsCount">Число точек на большей окружности</param>
            <param name="SecondNomnalsCount">Число точек на меньшей окружности</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.DCircle.GetNormalsOnDCircle(System.Double)">
            <summary>
            Возвращает массив точек и массив нормалей в этих точках
            </summary>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Waves.Turn(МатКлассы.Point,МатКлассы.Point,System.Double)">
            <summary>
            Поворот точки на угол относительно центра
            </summary>
            <param name="p"></param>
            <param name="center"></param>
            <param name="corner"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.ИнтеграцияСДругимиПрограммами">
            <summary>
            Класс всяких полезных штук для работы с другими программами
            </summary>
        </member>
        <member name="M:МатКлассы.ИнтеграцияСДругимиПрограммами.CreatTableInExcel(МатКлассы.DRealFunc,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Создать в Excel таблицу, по которой можно построить 3D поверхность
            </summary>
            <param name="f">Функция двух переменных</param>
            <param name="x0">Начало отрезка по первому аргументу</param>
            <param name="X">Конец отрезка по первому аргументу</param>
            <param name="xcount">Число шагов по первому аргументу</param>
            <param name="y0">Начало отрезка по второму аргументу</param>
            <param name="Y">Конец отрезка по второму аргументу</param>
            <param name="ycount">Число шагов по второму аргументу</param>
        </member>
        <member name="M:МатКлассы.ИнтеграцияСДругимиПрограммами.CreatTableInExcel``1(``0[],МатКлассы.Vectors[])">
            <summary>
            Создать в Excel таблицу, по которой можно построить серию графиков функциё одной переменной
            </summary>
            <param name="args">Массив аргументов</param>
            <param name="values">Массив векторов значений</param>
        </member>
        <member name="M:МатКлассы.ИнтеграцияСДругимиПрограммами.CreatTableInExcel(System.Double[][])">
            <summary>
            Создать в Excel таблицу, по таблице double
            </summary>
        </member>
        <member name="M:МатКлассы.ИнтеграцияСДругимиПрограммами.CreatTableInExcel(System.Collections.Concurrent.ConcurrentDictionary{МатКлассы.Point,System.Lazy{МатКлассы.Number.Complex}},System.String,МатКлассы.Number.Complex.ComplMode)">
            <summary>
            Создать таблицу по словарю Точка-Комплексное число
            </summary>
            <typeparam name="Targ"></typeparam>
            <param name="dic"></param>
        </member>
        <member name="M:МатКлассы.ИнтеграцияСДругимиПрограммами.CreatTableInExcel(МатКлассы.DComplexFunc,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32,System.Collections.Concurrent.ConcurrentDictionary{МатКлассы.Point,System.Lazy{МатКлассы.Number.Complex}},System.Boolean)">
            <summary>
            Создать таблицу и графики по комплексной функции двух действительных переменных
            </summary>
            <param name="f">Функция</param>
            <param name="x0"></param>
            <param name="X"></param>
            <param name="xcount">Число шагов по оси Х</param>
            <param name="y0"></param>
            <param name="Y"></param>
            <param name="ycount">Число шагов по оси Y</param>
            <param name="dic">Дополнительный словарь значений</param>
            <param name="withgraph">Нужно ли вдобавок рисовать графики</param>
        </member>
        <member name="T:МатКлассы.CnToCFunction">
            <summary>
            Комплексная функция многих переменных
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.CVecToCMatrix">
            <summary>
            Матричная функция от векторного аргумента
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.RToC">
            <summary>
            Функция R->C
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.CkToCnFunc">
            <summary>
            Класс функции, осуществляющей отображение Ck -> Cn
            </summary>
        </member>
        <member name="T:МатКлассы.CkToCnFunc.VecToVec">
            <summary>
            Делегат, отождествляемый с унитарным отображением
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.CkToCnFunc.EDimention">
            <summary>
            Размерность области значений
            </summary>
        </member>
        <member name="P:МатКлассы.CkToCnFunc.Item(МатКлассы.CVectors)">
            <summary>
            Значение функции от вектора через индексатор
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.CkToCnFunc.Item(System.Int32)">
            <summary>
            Функция отдельного измерения
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.Value(МатКлассы.CVectors)">
            <summary>
            Метод, возвращающий значение функции от вектора
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.Value(МатКлассы.Number.Complex[])">
            <summary>
            Значение функции от вектора
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.#ctor(МатКлассы.CnToCFunction[])">
            <summary>
            Задание функции как совокупности комплексных функций многих переменных
            </summary>
            <param name="mas"></param>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.#ctor(МатКлассы.CSqMatrix,МатКлассы.CkToCnFunc)">
            <summary>
            Задать унитарную функции как произведение унитарной функции на комплексную матрицу
            </summary>
            <param name="M"></param>
            <param name="F"></param>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.#ctor(МатКлассы.CVecToCMatrix,МатКлассы.CkToCnFunc)">
            <summary>
            Задать унитарную функции как произведение унитарной функции на кматричную функцию
            </summary>
            <param name="M"></param>
            <param name="F"></param>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.#ctor(МатКлассы.CkToCnFunc.VecToVec)">
            <summary>
            Задать функцию через делегат отображения
            </summary>
            <param name="f"></param>
        </member>
        <member name="T:МатКлассы.CkToCnFunc.CarringType">
            <summary>
            Тип каррирования
            </summary>
        </member>
        <member name="F:МатКлассы.CkToCnFunc.CarringType.FirstArgs">
            <summary>
            По первым аргументам
            </summary>
        </member>
        <member name="F:МатКлассы.CkToCnFunc.CarringType.LastArgs">
            <summary>
            По последним аргументам
            </summary>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.CarrByFirstOrLastArgs(МатКлассы.CkToCnFunc.CarringType,МатКлассы.Number.Complex[])">
            <summary>
            Каррирование отображения в соответствии с параметрами
            </summary>
            <param name="C">Параметр каррирования</param>
            <param name="c">Фиксированные аргументы</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.CkToCnFunc.IntegralAmoutOneArg(МатКлассы.CVectors,МатКлассы.CVectors,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Интеграл от отображения по одному аргументу (другие зафиксированы)
            </summary>
            <param name="beforeArg">Фиксированные аргументы до изменяемого</param>
            <param name="afterArg">Фиксированные аргументы после изменяемого</param>
            <param name="t1"></param>
            <param name="t2"></param>
            <param name="t3"></param>
            <param name="t4"></param>
            <param name="tm"></param>
            <param name="tp"></param>
            <param name="eps"></param>
            <param name="pr"></param>
            <param name="gr"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.OptimizationDCompFunc">
            <summary>
            Класс оптимизации функции двух аргументов
            </summary>
        </member>
        <member name="M:МатКлассы.OptimizationDCompFunc.GetMaxOnRectangle(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Поиск минимума функции на прямоугольнике, чьи стороны параллельны осям координат
            </summary>
            <param name="f">Оптимизируемая функция</param>
            <param name="x0"></param>
            <param name="X"></param>
            <param name="y0"></param>
            <param name="Y"></param>
            <param name="nodescount">Корень из числа точек, берущихся в прямоугольнике (нижняя граница, потому что если прямоугольник слишком далёк от квадрата, надо брять другое соотношение)</param>
            <param name="eps">Погрешность поиска</param>
            <param name="ogr">Через сколько максимально итераций нужно закончить цикл, если последние ogr итераций подряд точка максимума не изменялась</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.OptimizationDCompFunc.Gradient(МатКлассы.ComplexFunc,МатКлассы.Number.Complex@,System.Double,System.Int32,System.Double)">
            <summary>
            Метод градиентного спуска к максимуму по модулю от функции
            </summary>
            <param name="f">Функция комплексного переменного</param>
            <param name="point">Начальная точка</param>
            <param name="alp">Коэффициент метода</param>
            <param name="maxcount">Максимальное число итераций</param>
            <param name="eps">Погрешность</param>
        </member>
        <member name="T:МатКлассы.SpecialFunctions">
            <summary>
            Некоторые специальные функции
            </summary>
        </member>
        <member name="M:МатКлассы.SpecialFunctions.MyBessel(System.Double,МатКлассы.Number.Complex)">
            <summary>
            Функция Бесселя
            </summary>
            <param name="a">Порядок</param>
            <param name="x">Аргумент</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SpecialFunctions.MyBessel(System.Double,System.Double)">
            <summary>
            Функция Бесселя
            </summary>
            <param name="a">Порядок</param>
            <param name="x">Аргумент</param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.SpecialFunctions.Hankel(System.Double,System.Double)">
            <summary>
            Функция Ханкеля первого рода
            </summary>
            <param name="a"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.ForScripts">
            <summary>
            Класс разных методов, которые я затем использую в комбинации со скриптами
            </summary>
        </member>
        <member name="M:МатКлассы.ForScripts.MakeFilesForSurfaces(System.Double,System.Double,System.Double,System.Double,System.Int32,System.String,МатКлассы.Functional[],System.Func{МатКлассы.Point,System.Boolean},System.Boolean)">
            <summary>
            Создать файлы для последующего создания поверхностей. 
            </summary>
            <param name="x0">Минимальное значение аргумента х</param>
            <param name="X">Максимальное значение аргумента х</param>
            <param name="argcount">Число точек по аргументу</param>
            <param name="filename">Базовое имя файла</param>
            <param name="f">Массив функций, от которых нужны поверхности</param>
            <param name="filter">Фильтр принадлежности области, на которой надо рисовать</param>
        </member>
        <member name="T:МатКлассы.BSpline">
            <summary>
            B-сплайны дефекта 1
            </summary>
        </member>
        <member name="F:МатКлассы.BSpline.xk">
            <summary>
            Массив узлов
            </summary>
        </member>
        <member name="M:МатКлассы.BSpline.#ctor(МатКлассы.CVectors)">
            <summary>
            Создать сплайн по массиву узлов
            </summary>
            <param name="mas"></param>
        </member>
        <member name="T:МатКлассы.ComplexFunc">
            <summary>
            Комплексная функция комплексного аргумента
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Functional">
            <summary>
            Действительные функции от точки
            </summary>
            <param name="x">Аргумент - пара действительных чисел (x,y), реализованная как точка Point</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.DRealFunc">
            <summary>
            Действительная функция двух переменных
            </summary>
            <param name="u"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.DComplexFunc">
            <summary>
            Комплекснозначная функция двух действительных переменных
            </summary>
            <param name="x"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.DoubleComplexFunc">
            <summary>
            Комплексная функция двух переменных
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.VRealFunc">
            <summary>
            Вектор-функция от вектора и параметра
            </summary>
            <param name="x"></param>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.VectorFunc">
            <summary>
            Вектор-функция
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.VectorToVector">
            <summary>
            Функция из Rn в Rn
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.TwoVectorToVector">
            <summary>
            Функция двух векторов, выдающая вектор
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.AntiVectorFunc">
            <summary>
            Действительная функция векторного аргумента
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.RealFuncOfCompArg">
            <summary>
            Действительная функция комплексного переменного
            </summary>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.TripleFunc">
            <summary>
            Действительная функция трёх аргументов, необходимая для вычисления площади сегментов с параметрами tx, ty при радиусе кривой r
            </summary>
            <param name="tx"></param>
            <param name="ty"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.MultiFunc">
            <summary>
            Функция многих аргументов
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SequenceFunc">
            <summary>
            Действительная функция из какой-то системы функций
            </summary>
            <param name="x">Аргумент</param>
            <param name="k">Номер функции в системе</param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SeqPointFunc">
            <summary>
            Действительная функция от точки из системы функций
            </summary>
            <param name="z"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.SequencePol">
            <summary>
            Полином из системы полиномов
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.PointFunc">
            <summary>
            Функция, возвращающая точку в зависимости от параметра
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.DPointFunc">
            <summary>
            Функция, возвращающая точку в зависимости от двух параметров
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Kind">
            <summary>
            Перечисление "род": для криволинейных интегралов, полиномов Чебышёва и т.д.
            </summary>
        </member>
        <member name="T:МатКлассы.SequenceFuncKind">
            <summary>
            Ортогональные функции, ортонормированные, неортогональные
            </summary>
        </member>
        <member name="T:МатКлассы.Probability">
            <summary>
            Вероятности
            </summary>
        </member>
        <member name="T:МатКлассы.Probability.RandVal">
            <summary>
            Абстрактный класс случайной величины
            </summary>
        </member>
        <member name="P:МатКлассы.Probability.RandVal.M">
            <summary>
            Математическое ожидание
            </summary>
        </member>
        <member name="P:МатКлассы.Probability.RandVal.Dis">
            <summary>
            Дисперсия
            </summary>
        </member>
        <member name="T:МатКлассы.Probability.DisRandVal">
            <summary>
            Дискретная случайная величина
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.DisRandVal.X">
            <summary>
            Значения случайной величины
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.DisRandVal.p">
            <summary>
            Значения вероятностей
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.DisRandVal.F">
            <summary>
            Функция распределения
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.#ctor(System.Double[])">
            <summary>
            Конструктор по массиву вероятностей
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.#ctor(System.Int32)">
            <summary>
            Конструктор по умолчанию
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.#ctor(МатКлассы.Probability.DisRandVal)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.#ctor(System.IO.StreamReader)">
            <summary>
            Чтение из файла
            </summary>
            <param name="fs"></param>
        </member>
        <member name="P:МатКлассы.Probability.DisRandVal.FDist">
            <summary>
            Функция распределения дискретной случайной величины
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.ProbOne(System.Double[])">
            <summary>
            Подходит ли массив под массив вероятностей
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.Show">
            <summary>
            Проиллюстрировать
            </summary>
        </member>
        <member name="P:МатКлассы.Probability.DisRandVal.M">
            <summary>
            Мат. ожидание этой СВ
            </summary>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Probability.DisRandVal.Dis">
            <summary>
            Дисперсия
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.MatExp(МатКлассы.Probability.DisRandVal)">
            <summary>
            Мат. ожидание СВ
            </summary>
            <param name="R"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.Dispersion(МатКлассы.Probability.DisRandVal)">
            <summary>
            Дисперсия
            </summary>
            <param name="R"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.BegM(МатКлассы.Probability.DisRandVal,System.Int32)">
            <summary>
            Начальный момент
            </summary>
            <param name="R"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.CenM(МатКлассы.Probability.DisRandVal,System.Int32)">
            <summary>
            Центральный момент
            </summary>
            <param name="R"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.NerCheb(МатКлассы.Probability.DisRandVal,System.Double)">
            <summary>
            По неравенству Чебышева вероятность того, что случайная величина отклонится от мат. ожидания не менее чем на eps
            </summary>
            <param name="R"></param>
            <param name="eps"></param>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.op_Subtraction(МатКлассы.Probability.DisRandVal,System.Double)">
            <summary>
            Смещение СВ
            </summary>
            <param name="A"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.DisRandVal.op_ExclusiveOr(МатКлассы.Probability.DisRandVal,System.Int32)">
            <summary>
            Случайная величина в степени
            </summary>
            <param name="A"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:МатКлассы.Probability.ConRandVal">
            <summary>
            Непрерывная случайная величина
            </summary>
        </member>
        <member name="T:МатКлассы.Probability.ConRandVal.BasisDistribution">
            <summary>
            Тип распределения (нормальное, равномерное, пуассоновское, экспоненциальное и т. д.)
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.ConRandVal.x">
            <summary>
            Вспомогательная функция
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.ConRandVal.F">
            <summary>
            Функция распределения
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.ConRandVal.f">
            <summary>
            Плотность распределения
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.ConRandVal.m">
            <summary>
            Пока не известные мат. ожидание и дисперсия
            </summary>
        </member>
        <member name="F:МатКлассы.Probability.ConRandVal.d">
            <summary>
            Пока не известные мат. ожидание и дисперсия
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>
            Конструктор по функции распределения и плотности распределения
            </summary>
            <param name="A"></param>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor(System.Func{System.Double,System.Double})">
            <summary>
            Конструктор только по плотности распределению
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor(МатКлассы.Probability.ConRandVal)">
            <summary>
            Конструктор копирования
            </summary>
            <param name="S"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor(МатКлассы.Probability.ConRandVal.BasisDistribution,System.Double,System.Double)">
            <summary>
            Конструктор по одному из основных распределений с двумя аргументами
            </summary>
            <param name="Type"></param>
            <param name="m"></param>
            <param name="D"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor(System.Double)">
            <summary>
            Конструктор по параметру экспоненциального распределния
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.#ctor">
            <summary>
            Конструктор нормального распределения по умолчанию
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.op_ExclusiveOr(МатКлассы.Probability.ConRandVal,System.Int32)">
            <summary>
            Случайная величина в степени
            </summary>
            <param name="a"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.op_Subtraction(МатКлассы.Probability.ConRandVal,System.Double)">
            <summary>
            Сдвиг случайной величины
            </summary>
            <param name="A"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.MatExp(МатКлассы.Probability.ConRandVal)">
            <summary>
            Мат. ожидание
            </summary>
            <param name="R"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.Dispersion(МатКлассы.Probability.ConRandVal)">
            <summary>
            Дисперсия
            </summary>
            <param name="R"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.BegM(МатКлассы.Probability.ConRandVal,System.Int32)">
            <summary>
            Начальный момент
            </summary>
            <param name="R"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.CenM(МатКлассы.Probability.ConRandVal,System.Int32)">
            <summary>
            Центральный момент
            </summary>
            <param name="R"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.NerCheb(МатКлассы.Probability.ConRandVal,System.Double)">
            <summary>
            По неравенству Чебышева вероятность того, что случайная величина отклонится от мат. ожидания не менее чем на eps
            </summary>
            <param name="R"></param>
            <param name="eps"></param>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.Show">
            <summary>
            Вывести на консоль информацию о случайной величине
            </summary>
        </member>
        <member name="M:МатКлассы.Probability.ConRandVal.P(System.Double,System.Double)">
            <summary>
            Вероятность попадания случайной величины в интервал
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="P:МатКлассы.Probability.ConRandVal.M">
            <summary>
            Мат. ожидание
            </summary>
        </member>
        <member name="P:МатКлассы.Probability.ConRandVal.Dis">
            <summary>
            Дисперсия
            </summary>
        </member>
    </members>
</doc>
